import pyautogui
import time
import numpy as np
import matplotlib.pyplot as plt
from PIL import ImageGrab, Image, ImageEnhance
import cv2
from matplotlib import pyplot as plt
import subprocess
import copy
import os
from skimage.metrics import mean_squared_error
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


start_time =time.time()
#opening the game
subprocess.Popen(["D:\\Bejeweled 2 Deluxe\\Bejeweled2.exe"])
empty_board = [['⬛' for i in range(8)] for i in range(8)]
#windows title moving to the corner
win = pyautogui.getWindowsWithTitle('Bejeweled 2 Deluxe 1.0')[0]
array_with_cur_moves = []
win.activate()
win.moveTo(0, 0)

wylosowane_kolory = [(199, 22, 199), (225, 225, 55), (230, 220, 220), (255,175,0), (49, 171, 253), (19, 202, 19), (255, 99, 99),(0,0,0),(82, 76, 24),(255,255,255),(100,100,100),(200,249,74)]
            # in order: pink,               yellow,         white,          orange,      blue,         green,           red
kolory = ['pink','yellow','white','orange','blue','green','red','black','brown','rainbow','rock','bomb']
start_pos_x = 318
start_pos_y = 68
#coordinated for drawing dots on image
kordy = []
a = ''
import cProfile
def test():

    x, y = pyautogui.position()
    width, height = 85 * 8, 84 * 8

    screenshot = ImageGrab.grab(bbox=(start_pos_x, start_pos_y, start_pos_x + width, start_pos_y + height))

    plt.imshow(screenshot)
    plt.axis('on')
    plt.show()




    array_color = []
    for i in range(3):

        x, y = start_pos_x, start_pos_y
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))


        colors =[]

        for j in range(8):
            for i in range(8):
                new_x = x + 85 * i + 41
                new_y = y + 84 * j + 42

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))


                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break

        array_color.append(colors)
        color_mapping = {
            'pink': '🟪',
            'yellow': '🟨',
            'white': '⬜',
            'orange': '🟧',
            'blue': '🟦',
            'green': '🟩',
            'red': '🟥',
            'black': '⬛',
            'brown': '?',
            'rainbow': 'R',
            'rock': '🌫️',
            'bomb': '⚫'
        }
        color = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color[i][j] = color_mapping[colors[index]]

    for i in range(3):

        x, y = start_pos_x, start_pos_y
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
        #variable to make dots even or something
        t,t2 = 0 , -1
        colors =[]
        for j in range(8):

            for i in range(8):
                t+=1
                if t == 2:
                    t2+=1
                new_x = x + 85 * i + 6 - i + t2 + 2
                new_y = y + 84 * j + 42
                kordy.append((new_x-start_pos_x,new_y-start_pos_y))

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        array_color.append(colors)
        color_mapping = {
            'pink': '🟪',
            'yellow': '🟨',
            'white': '⬜',
            'orange': '🟧',
            'blue': '🟦',
            'green': '🟩',
            'red': '🟥',
            'black': '⬛',
            'brown': '🅿️',
            'rainbow': 'R',
            'rock': '🌫️',
            'bomb': '⚫'
        }
        color_power = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color_power[i][j] = color_mapping[colors[index]]
        for row in color_power:
            print(' '.join(row))



    # compare arrays to determine what is what
    first_color_array = []
    second_color_array = []
    for gem in color:
        first_color_array+=gem
    for gem in color_power:
        second_color_array+=gem

    print('first')
    for i in range(8):
        print(first_color_array[i*8],first_color_array[i*8+1],first_color_array[i*8+2],first_color_array[i*8+3],first_color_array[i*8+4],first_color_array[i*8+5],first_color_array[i*8+6],first_color_array[i*8+7])
    print('secomd')
    for i in range(8):
        print(second_color_array[i * 8], second_color_array[i * 8 + 1], second_color_array[i * 8 + 2],
              second_color_array[i * 8 + 3], second_color_array[i * 8 + 4], second_color_array[i * 8 + 5],
              second_color_array[i * 8 + 6], second_color_array[i * 8 + 7])

    #comparing
    #new array to have new board state
    pre_final_board = []
    for i in range(64):
        if second_color_array[i] == '🅿️' and first_color_array[i] == 'R':
            pre_final_board.append('⚪')
        elif second_color_array[i] == '⬛' and first_color_array[i] == 'R':
            pre_final_board.append('🌈')
        elif first_color_array[i] == '🟨' and second_color_array[i] != '🅿️':
            pre_final_board.append('🟨')
        elif first_color_array[i] == '🟥' and second_color_array[i] != '🅿️':
            pre_final_board.append('🟥')
        elif first_color_array[i] == '🟧' and second_color_array[i] != '🅿️':
            pre_final_board.append('🟧')
        elif first_color_array[i] == '🟦' and second_color_array[i] != '🅿️':
            pre_final_board.append('🟦')
        elif first_color_array[i] == '🟩' and second_color_array[i] != '🅿️':
            pre_final_board.append('🟩')
        elif first_color_array[i] == '🟪' and second_color_array[i] != '🅿️':
            pre_final_board.append('🟪')
        elif first_color_array[i] == '⬜' and second_color_array[i] != '🅿️':
            pre_final_board.append('⬜')
        elif first_color_array[i] == '🟨' and second_color_array[i] == '🅿️':
            pre_final_board.append('🟡')
        elif first_color_array[i] == '🟥' and second_color_array[i] == '🅿️':
            pre_final_board.append('🔴')
        elif first_color_array[i] == '🟧' and second_color_array[i] == '🅿️':
            pre_final_board.append('🟠')
        elif first_color_array[i] == '🟦' and second_color_array[i] == '🅿️':
            pre_final_board.append('🔵')
        elif first_color_array[i] == '🟩' and second_color_array[i] == '🅿️':
            pre_final_board.append('🟢')
        elif first_color_array[i] == '🟪' and second_color_array[i] == '🅿️':
            pre_final_board.append('🟣')
        elif first_color_array[i] == '⬛' and second_color_array[i] == '⬛':
            pre_final_board.append('⬛')
        elif first_color_array[i] == '🌫️' and second_color_array[i] == '⬛':
            pre_final_board.append('🌫️')
        elif first_color_array[i] == '🅿️' and second_color_array[i] == '⬛':
            pre_final_board.append('⚫')
        elif first_color_array[i] == '🅿️' and second_color_array[i] == '⚫':
            pre_final_board.append('⚫')
        elif first_color_array[i] == '⚫' and second_color_array[i] == '🅿️':
            pre_final_board.append('⚫')
        else:
            pre_final_board.append('⚫')
    # 🔴🟠🟡🟢🔵🟣
    print(f'pre array{pre_final_board}')
    final_board = [['' for _ in range(8)] for _ in range(8)]
    color_mapping = {
        '🟨': '🟨',
        '🟦': '🟦',
        '🟪': '🟪',
        '⬜': '⬜',
        '🟩': '🟩',
        '🟧': '🟧',
        '🟥': '🟥',
        '🔵': '🔵',
        '⚪': '⚪',
        '🌈': '🌈',
        '🔴': '🔴',
        '🟣': '🟣',
        '🟢': '🟢',
        '🟠': '🟠',
        '🟡': '🟡',
        '⬛': '⬛',
        '🌫️': '🌫️',
        '⚫': '⚫',
        '🅿️': '⚫'
    }

    for i, emoji in enumerate(pre_final_board):
        row = i // 8
        col = i % 8
        final_board[row][col] = color_mapping.get(emoji, 'unknown')


    for row in final_board:
        print(row)
    end_time = time.time()
    print(f' elapsed in seconds:{end_time - start_time}')
    global original_board
    original_board =copy.deepcopy(final_board)
    print(f' orig {original_board}') # dobry
    #convert the board to cound powered gems as normal gems so you can make moves with normal and powered
    converted_board = [['' for _ in range(8)] for _ in range(8)]
    emoji_mapping = {
        '🟧': '🟧',
        '🟨': '🟨',
        '🟦': '🟦',
        '🟩': '🟩',
        '🟪': '🟪',
        '⬜': '⬜',
        '🟥': '🟥',
        '🌈': '🌈',
        '⚪': '⬜',
        '🔵': '🟦',
        '🔴': '🟥',
        '🟣': '🟪',
        '🟢': '🟩',
        '🟠': '🟧',
        '🟡': '🟨',
        '⬛': '⬛',
        '🌫️': '🌫️',

        '🅿️': '⚫'
    }
    for i in range(8):
        for j in range(8):
            gem = final_board[i][j]
            if gem in emoji_mapping:
                converted_board[i][j] = emoji_mapping[gem]
            else:
                converted_board[i][j] = gem
    for row in converted_board:
        print(' '.join(row))
    array_with_moves = check_for_moves(converted_board)
    print(f'{array_with_moves}')
    sieved_moves = sieve_moves(array_with_moves)
    print(f'sieved moves {sieved_moves}')
    #make_moves_function(final_moves)
    #print('check nums on bombs')
    check_nums_on_bombs(original_board)
    folder_bombs = 'bombs'
    folder_all_bombs = 'all_bombs'
    bombs = []
    for bomb_image in os.listdir(folder_bombs):
        bomb_image_path = os.path.join(folder_bombs, bomb_image)
        best_match = None
        lowest_mse = float('inf')

        for all_bomb_image in os.listdir(folder_all_bombs):
            all_bomb_image_path = os.path.join(folder_all_bombs, all_bomb_image)
            mse = compare_images(bomb_image_path, all_bomb_image_path)
            if mse < lowest_mse:
                lowest_mse = mse
                best_match = all_bomb_image
        print(f"Najbardziej podobny obraz dla {bomb_image}: {best_match}")
        bombs.append(best_match)
    print(f' bombs {bombs}')
    bomb_board = [['' for _ in range(8)] for _ in range(8)]
    bomb_number = 0
    for i in range(8):
        for j in range(8):
            if original_board[j][i] != '⚫' :
                bomb_board[j][i] = original_board[j][i]
                print(bomb_board)
            else:
                if bomb_number == 0:
                    bomb_number += 1
                    bomb_board[j][i] = bombs[0][0]
                else:
                    bomb_board[j][i] = bombs[1][0]
    for row in bomb_board:
        print(' '.join(row))

def check_nums_on_bombs(board):
    bombs_pos = []
    for i in range(8):
        for j in range(8):
            if board[j][i] == '⚫':
                print(f' x {i} y {j}')
                pos = (i, j)
                bombs_pos.append(pos)
    folder_path = 'bombs'
    for filename in os.listdir(folder_path):
        file_path = os.path.join(folder_path, filename)
        os.remove(file_path)
    for pos in bombs_pos:

        start_pos_x = 318+ pos[0]*85
        start_pos_y = 68+ pos[1]*84
        # coordinated for drawing dots on image

        x, y = pyautogui.position()
        width, height = 85, 84
        screenshot = ImageGrab.grab(bbox=(start_pos_x, start_pos_y, start_pos_x + width, start_pos_y + height))
        plt.imshow(screenshot)
        plt.axis('on')
        plt.show()
        image_number = len(os.listdir(folder_path)) + 1
        image_filename = f'bombs_{image_number}.png'
        image_path = os.path.join(folder_path, image_filename)


        screenshot.save(image_path, 'PNG')

def compare_images(image1_path, image2_path):
    image1 = Image.open(image1_path)
    image2 = Image.open(image2_path)
    mse = mean_squared_error(np.array(image1), np.array(image2))
    return mse

def flag_rows(board_without_powered): # flag that checks if boards does have 3-rows or not
    for i in range(8):
        for j in range(8):
            if j <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] == board_without_powered[j + 4][
                i] != "⬛":
                return True
            elif i <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] == board_without_powered[j][
                i + 4] != "⬛":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            elif j <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] != "⬛":
                return True
            elif i <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] != "⬛":
                return True
            elif j <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] != "⬛":
                return True
            elif i <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] != "⬛":
                return True
    return False

def check_for_moves(final_board):
    horizontal_pair_of_gems = []
    vertical_pair_of_gems = []
    available_vertical_moves = 0

    #moves based off of position of the gem that will create a move, ie. the one that dissapeares after move
    #gem positions will be stored here and off of those arrays moves will be calculated
    moves_to_left = []
    moves_to_right = []
    moves_to_down = []
    moves_to_up = []

    for i in range(8):
        for j in range(7):
            if final_board[i][j] == final_board[i][j + 1]:
                horizontal_pair_of_gems.append(((j,i),(j+1,i)))
    for j in range(8):
        for i in range(7):
            if final_board[i][j] == final_board[i+1][j]:
                vertical_pair_of_gems.append(((j,i),(j,i+1)))

    for i in range(len(vertical_pair_of_gems)):



            if (vertical_pair_of_gems[i][0][1])-1 > -1 and (vertical_pair_of_gems [i][0][0])-1 > -1:
                if (final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems [i][0][0])-1] and
                        final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] != '⬛' and
                        final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] != '🌫️' and
                        final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems [i][0][0])-1] != '🌫️' and
                        final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems [i][0][0])-1] != '⬛'):

                    move = ((vertical_pair_of_gems[i][0][0]) - 1, vertical_pair_of_gems[i][0][1] - 1,'right',3)
                    if move not in moves_to_right:

                        moves_to_right.append(move)
                    available_vertical_moves += 1
            if (vertical_pair_of_gems[i][0][1])-1 > -1 and (vertical_pair_of_gems[i][0][0])+1 < 8:
                if (final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1] and
                        final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] != '⬛' and
                        final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] != '🌫️' and
                        final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1] != '⬛' and
                        final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1] != '🌫️'):

                    move = ((vertical_pair_of_gems[i][0][0])+1,(vertical_pair_of_gems[i][0][1])-1,'left',3)
                    if move not in moves_to_left:

                        moves_to_left.append(move)
                    available_vertical_moves += 1
            if (vertical_pair_of_gems[i][0][1])-2 > -1:
                if (final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])] and
                        final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])]!= '⬛' and
                        final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])]!= '🌫️' and
                        final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]!= '⬛' and
                        final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]!= '🌫️'):

                    move = ((vertical_pair_of_gems[i][0][0]),(vertical_pair_of_gems[i][0][1])-2,'down',3)
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_vertical_moves += 1

    for i in range(len(vertical_pair_of_gems)):
            if (vertical_pair_of_gems[i][1][1])+1 < 8 and (vertical_pair_of_gems[i][1][0])-1 > -1:
                if (final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1] and
                        final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])]!= '⬛' and
                        final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])]!= '🌫️' and
                        final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]!= '⬛' and
                        final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]!= '🌫️'):

                    move = ((vertical_pair_of_gems[i][1][0])-1,(vertical_pair_of_gems[i][1][1])+1,'right',3)
                    if move not in moves_to_right:

                        moves_to_right.append(move)
                    available_vertical_moves += 1
            if (vertical_pair_of_gems[i][1][1])+1 < 8 and (vertical_pair_of_gems[i][1][0])+1 < 8:
                if (final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1] and
                        final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])]!= '⬛'and
                        final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])]!= '🌫️'and
                        final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]!= '⬛'and
                        final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]!= '🌫️'):

                    move = ((vertical_pair_of_gems[i][1][0])+1,(vertical_pair_of_gems[i][1][1])+1,'left',3)
                    if move not in moves_to_left:

                        moves_to_left.append(move)
                    available_vertical_moves += 1
            if (vertical_pair_of_gems[i][1][1])+2 < 8:
                if (final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])] and
                    final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])]!= '⬛'and
                    final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])]!= '🌫️'and
                    final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])]!= '⬛'and
                    final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])]!= '🌫️'):

                    move = ((vertical_pair_of_gems[i][1][0]),(vertical_pair_of_gems[i][1][1])+2,'up',3)
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_vertical_moves += 1
    if available_vertical_moves != 0:
        print(f'{bcolors.OKBLUE}VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')

    available_horizontal_moves = 0
    #print(f'################ HORIZONTAL MOVES #####################')
    for i in range(len(horizontal_pair_of_gems)):
            if (horizontal_pair_of_gems[i][0][1])-1 > -1 and (horizontal_pair_of_gems[i][0][0])-1 > -1:
                if (final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1] and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]!= '⬛'and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]!='🌫️'and
                    final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]!= '⬛'and
                    final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]!= '🌫️'):

                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])-1,'down',3)
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1
            if (horizontal_pair_of_gems[i][0][1])+1 < 8 and (horizontal_pair_of_gems[i][0][0])-1 > -1:
                if (final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1] and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]!= '⬛' and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]!='🌫️'and
                    final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]!= '⬛'and
                    final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]!= '🌫️'):

                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])+1,'up',3)
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1
            if (horizontal_pair_of_gems[i][0][0])-2 > -1:
                if (final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2] == final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2]!= '⬛'and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2]!='🌫️'and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] != '⬛'and
                    final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] != '🌫️'):

                    move = ((horizontal_pair_of_gems[i][0][0])-2,(horizontal_pair_of_gems[i][0][1]),'right',3)
                    if move not in moves_to_right:

                        moves_to_right.append(move)
                    available_horizontal_moves += 1

    for i in range(len(horizontal_pair_of_gems)):
            if (horizontal_pair_of_gems[i][1][1])-1 > -1 and  (horizontal_pair_of_gems[i][1][0])+1 < 8:
                if (final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]!= '⬛'and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]!='🌫️'and
                        final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]!= '⬛'and
                        final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]!= '🌫️'):

                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])-1,'down',3)
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1
            if (horizontal_pair_of_gems[i][1][1])+1 < 8 and (horizontal_pair_of_gems[i][1][0])+1 < 8:
                if (final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]!= '⬛'and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]!='🌫️'and
                        final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1] != '⬛'and
                        final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1] != '🌫️'):

                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])+1,'up',3)
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1
            if (horizontal_pair_of_gems[i][1][0])+2 < 8:
                if (final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2] == final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2]!= '⬛'and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2]!='🌫️'and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] != '⬛'and
                        final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] != '🌫️'):

                    move = ((horizontal_pair_of_gems[i][1][0])+2,(horizontal_pair_of_gems[i][1][1]),'left',3)
                    if move not in moves_to_left:

                        moves_to_left.append(move)
                    available_horizontal_moves += 1
    if available_horizontal_moves != 0:
        print(f'{bcolors.OKBLUE}HORIZONTAL MOVES: {available_horizontal_moves}{bcolors.ENDC}')

    #checking for moves that would be 2 in same row and 1 higher/lower/left/right but in the middle in general
    for i in range(8):
        for j in range(8):
            try:
                if j + 2 < 8:
                    pass
                else:pass

                if (final_board[i][j] == final_board[i][j+2]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!= '🌫️'and
                        final_board[i][j+2]!= '⬛'and
                        final_board[i][j+2]!= '🌫️'):
                    if i+1 < 8 and j+1 < 8:
                        if (final_board[i][j] == final_board[i+1][j+1]and
                                final_board[i][j]!= '⬛'and
                                final_board[i][j]!= '🌫️'and
                                final_board[i+1][j+1]!= '⬛'and
                                final_board[i+1][j+1]!= '🌫️'):
                            #print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            #print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'up',3)
                            if move not in moves_to_up:

                                moves_to_up.append(move)


                    if i-1 > -1 and j+1 < 8:
                        if (final_board[i][j] == final_board[i-1][j+1]and
                                final_board[i][j]!= '⬛'and
                                final_board[i][j]!= '🌫️'and
                                final_board[i-1][j+1]!= '⬛'and
                                final_board[i-1][j+1]!= '🌫️'):
                            #print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            #print(f'move found with gem at x: {j+1} y: {i-1}')
                            move = (j+1,i-1,'down',3)
                            if move not in moves_to_down:

                                moves_to_down.append(move)

            except:pass
    #same but vertical

    for i in range(8):
        for j in range(8):
            try:
                if i + 2 < 8:
                    pass
                else:pass
                if (final_board[i][j] == final_board[i+2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'and
                        final_board[i+2][j]!= '⬛'and
                        final_board[i+2][j]!= '🌫️'):
                    if i+1 < 8 and j+1 < 8:
                        if (final_board[i][j] == final_board[i+1][j+1]and
                                final_board[i][j]!= '⬛'and
                                final_board[i][j]!='🌫️'and
                                final_board[i+1][j+1] != '⬛'and
                                final_board[i+1][j+1] != '🌫️'):
                            #print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            #print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'left',3)
                            if move not in moves_to_left:
                                moves_to_left.append(move)
                    if i+1 < 8 and j-1 > -1:
                        if (final_board[i][j] == final_board[i+1][j-1]and
                                final_board[i][j]!= '⬛'and
                                final_board[i][j]!='🌫️'and
                                final_board[i+1][j-1]!= '⬛'and
                                final_board[i+1][j-1]!= '🌫️'):
                            #print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            #print(f'move found with gem at x: {j-1} y: {i+1}')
                            move = ( j - 1,i + 1,'right',3)
                            if move not in moves_to_right:

                                moves_to_right.append(move)

            except:pass

    #print('############ MOVES BY 4 ###############')
    #moves by 4!!! horizontal
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if (final_board[i][j] == final_board[i][j + 2]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!= '🌫️'and
                        final_board[i][j + 2]!= '⬛'and
                        final_board[i][j + 2]!= '🌫️'): # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if (final_board[i][j] == final_board[i + 1][j + 1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i + 1][j + 1]!= '⬛'and
                                    final_board[i + 1][j + 1]!= '🌫️'):
                                if j+3 < 8:
                                    if (final_board[i][j] == final_board[i][j+3]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j+3]!= '⬛'and
                                            final_board[i][j+3]!= '🌫️'):
                                        move = (j+1,i+1,'up','4l')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)
                                        #
                                        #X 00     X - poggladowy gem x,y
                                        # 0
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j+2} {i} fourth gem at x: {j+3} {i}')
                        if i - 1 > -1 and j + 1 < 8:
                            if (final_board[i][j] == final_board[i - 1][j + 1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i - 1][j + 1]!= '⬛'and
                                    final_board[i - 1][j + 1]!= '🌫️'):
                                if j+3 < 8:
                                    if (final_board[i][j] == final_board[i][j+3]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j+3]!= '⬛'and
                                            final_board[i][j+3]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j + 2} {i} fourth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'down','4l')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                                        # 0
                                        #X 00
                                        #
                        if i - 1 > -1 and j + 1 < 8:
                            if (final_board[i][j] == final_board[i - 1][j + 1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i - 1][j + 1]!= '⬛'and
                                    final_board[i - 1][j + 1]!= '🌫️'):
                                if j-1 > -1:
                                    if (final_board[i][j] == final_board[i][j - 1]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j - 1]!= '⬛'and
                                            final_board[i][j - 1]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j+2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i - 1,'down','4r')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                                        #  0
                                        #X0 0
                                        #
                        if i + 1 < 8 and j + 1 < 8:
                            if (final_board[i][j] == final_board[i + 1][j + 1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i + 1][j + 1]!= '⬛'and
                                    final_board[i + 1][j + 1]!= '🌫️'):
                                if j - 1 > -1:
                                    if (final_board[i][j] == final_board[i][j - 1]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j - 1]!= '⬛'and
                                            final_board[i][j - 1]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j + 2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i + 1,'up','4r')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)
                                        #
                                        #X0 0
                                        #  0

    #vertical;
    #print("@@@@@@@@@@@@@@@ 4 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

           if i + 2 < 8:
                if (final_board[i][j] == final_board[i+2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'and
                        final_board[i+2][j]!= '⬛'and
                        final_board[i+2][j]!= '🌫️'):
                        if i+1 < 8 and j+1 < 8:
                            if (final_board[i][j] == final_board[i+1][j+1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i+1][j+1]!= '⬛'and
                                    final_board[i+1][j+1]!= '🌫️'):
                                if i + 3 < 8:
                                    if (final_board[i][j] == final_board[i+3][j]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i+3][j]!= '⬛'and
                                            final_board[i+3][j]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j + 1,i + 1 ,'left','4u')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)
                                        # X
                                        #  0
                                        # 0
                                        # 0
                        if i+1 < 8 and j-1 > -1:
                            if (final_board[i][j] == final_board[i+1][j-1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i+1][j-1]!= '⬛'and
                                    final_board[i+1][j-1]!= '🌫️'):
                                if i + 3 < 8:
                                    if (final_board[i][j] == final_board[i+3][j]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i+3][j]!= '⬛'and
                                            final_board[i+3][j]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j-1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j - 1,i + 1 ,'right','4u')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                                        # X
                                        #0
                                        # 0
                                        # 0
                        if j-1 > -1 and i+1 < 8 and i -1 > -1 :
                            if (final_board[i][j] == final_board[i+1][j-1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i+1][j-1]!= '⬛'and
                                    final_board[i+1][j-1]!= '🌫️'):
                                if i + 3 < 8:
                                    if (final_board[i][j] == final_board[i - 1][j]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i - 1][j]!= '⬛'and
                                            final_board[i - 1][j]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j - 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j - 1,i + 1,'right','4d')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                                        # 0
                                        # X
                                        #0
                                        # 0
                        if i+1 < 8 and j+1 < 8 and i -1 > -1 :
                            if (final_board[i][j] == final_board[i+1][j+1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i+1][j+1] != '⬛'and
                                    final_board[i+1][j+1] != '🌫️'):
                                if i + 3 < 8:
                                    if (final_board[i][j] == final_board[i-1][j]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i-1][j]!= '⬛'and
                                            final_board[i-1][j]!= '🌫️'):
                                        #print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j + 1,i + 1,'left','4d')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)
                                        # 0
                                        # X
                                        #  0
                                        # 0
    ##################### L MOVES ######################
    for i in range(8):
        for j in range(8):
            #0
            #0
            # 00
            #X
            if i-3 > -1 and j+2 < 8:
                if (final_board[i][j] == final_board[i-2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i - 3][j] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i - 1][j+1] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i - 1][j+2] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('└d')
                                move=(j,i,'up','└d')
                                if move not in moves_to_up:
                                    moves_to_up.append(move)
            #  0
            #  0
            #00
            #  X
            if i-3 > -1 and j-2 >-1:
                if (final_board[i][j] == final_board[i-2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i - 3][j] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i - 1][j-1] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i - 1][j-2] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️'):
                                #print('┘d')
                                move=(j,i, 'up', '┘d')
                                if move not in moves_to_up:

                                    moves_to_up.append(move)
            #  0
            #  0
            #00 X

            if i-2 > -1 and j-3 >-1:
                if (final_board[i][j] == final_board[i-1][j-1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i - 2][j-1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️'):
                        if (final_board[i][j] == final_board[i][j-2] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️'):
                            if (final_board[i][j] == final_board[i][j-3] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️'):
                                #print('┘r')
                                move=(j,i, 'left', '┘r')
                                if move not in moves_to_left:
                                    moves_to_left.append(move)
            # 0
            # 0
            #X  00

            if i-2 > -1 and j+3 < 8:
                if (final_board[i][j] == final_board[i-2][j+1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i - 1][j+1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i][j+2] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️'):
                            if (final_board[i][j] == final_board[i][j+3] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('└l')
                                move=(j,i, 'right', '└l')
                                if move not in moves_to_right:

                                    moves_to_right.append(move)

            #X
            # 00
            #0
            #0
            if i+3< 8 and j+2 < 8:
                if (final_board[i][j] == final_board[i+2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i + 3][j] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i + 1][j+1] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i + 1][j+2] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('┌u')
                                move=(j,i, 'down', '┌u')
                                if move not in moves_to_down:

                                    moves_to_down.append(move)

            #  X
            #00
            #  0
            #  0
            if i+3 <8 and j-2 >-1:
                if (final_board[i][j] == final_board[i+2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i + 3][j] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i + 1][j-1] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i + 1][j-2] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️'):
                                #print('┐u')
                                move=(j,i, 'down', '┐u')
                                if move not in moves_to_down:

                                    moves_to_down.append(move)

            #00 X
            #  0
            #  0
            if i+2 < 8 and j-3 >-1:
                if (final_board[i][j] == final_board[i+1][j-1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i + 2][j-1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️'):
                        if (final_board[i][j] == final_board[i][j-2] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️'):
                            if (final_board[i][j] == final_board[i][j-3] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️'):
                                #print('┐r')
                                move=(j,i, 'left', '┐r')
                                if move not in moves_to_left:

                                    moves_to_left.append(move)

            #X 00
            # 0
            # 0
            if i+2 < 8 and j+3 < 8:
                if (final_board[i][j] == final_board[i+2][j+1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i + 1][j+1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i][j+2] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️'):
                            if (final_board[i][j] == final_board[i][j+3] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('┌l')
                                move=(j,i, 'right', '┌l')
                                if move not in moves_to_right:

                                    moves_to_right.append(move)

    ##################### T MOVES #######################
    for i in range(8):
        for j in range(8):
            # 0
            #X 00
            # 0
            if i-1 > -1 and j+3 < 8 and i+1 < 8:
                if (final_board[i][j] == final_board[i-1][j+1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i +1][j+1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i][j+2] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i][j+3] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('└d')
                                move=(j,i,'right','┝l')
                                if move not in moves_to_up:
                                    moves_to_up.append(move)
            #  0
            #00 X
            #  0
            if i-1 > -1 and j-3 >-1 and i+1 < 8:
                if (final_board[i][j] == final_board[i-1][j-1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i +1][j-1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i][j-2] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i][j-3] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('└d')
                                move=(j,i,'left','┥r')
                                if move not in moves_to_up:
                                    moves_to_up.append(move)
            # X
            #0 0
            # 0
            # 0
            if i+3 < 8 and j-1 >-1 and j+1 < 8:
                if (final_board[i][j] == final_board[i+1][j-1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i +1][j-1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i+2][j] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i+3][j] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('└d')
                                move=(j,i,'down','┬u')
                                if move not in moves_to_up:
                                    moves_to_up.append(move)
            # 0
            # 0
            #0 0
            # X
            if i-3 < 8 and j-1 >-1 and j+1 < 8:
                if (final_board[i][j] == final_board[i-1][j-1]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'):
                    if (final_board[i][j] == final_board[i-1][j+1] and
                            final_board[i][j] != '⬛' and
                            final_board[i][j] != '🌫️' ):
                        if (final_board[i][j] == final_board[i-2][j] and
                                final_board[i][j] != '⬛' and
                                final_board[i][j] != '🌫️' ):
                            if (final_board[i][j] == final_board[i-3][j] and
                                    final_board[i][j] != '⬛' and
                                    final_board[i][j] != '🌫️' ):
                                #print('└d')
                                move=(j,i,'up','┴d')
                                if move not in moves_to_up:
                                    moves_to_up.append(move)
    #print('$$$$$$$$$$$$$$ MOVES BY 5 $$$$$$$$$$$$$$$$$')
    for i in range(8):
        for j in range(8):

            if j + 2 < 8:
                if (final_board[i][j] == final_board[i][j + 2]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'and
                        final_board[i][j + 2]!= '⬛'and
                        final_board[i][j + 2]!= '🌫️'): # sprawdzianie czy gem o 2 jest taki sam
                        if i + 1 < 8 and j + 1 < 8:
                            if (final_board[i][j] == final_board[i + 1][j + 1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i + 1][j + 1]!= '⬛'and
                                    final_board[i + 1][j + 1]!= '🌫️'):
                                if j+3 < 8 and j - 1 > -1:
                                    if (final_board[i][j] == final_board[i][j+3]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j+3]!= '⬛'and
                                            final_board[i][j+3]!= '🌫️'and
                                            final_board[i][j] == final_board[i][j-1]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j-1]!= '⬛'and
                                            final_board[i][j-1]!= '🌫️'):
                                        #print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j-1} {i}  third gem at {j} {i} fourth {j+2} {i} fifth gem at x: {j+3} {i}')
                                        move = (j + 1,i + 1,'up',5)
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if( final_board[i][j] == final_board[i - 1][j + 1]and
                                    final_board[i][j]!= '⬛'and
                                    final_board[i][j]!='🌫️'and
                                    final_board[i - 1][j + 1]!= '⬛'and
                                    final_board[i - 1][j + 1]!= '🌫️'):
                                if j+3 < 8 and j - 1 > -1:
                                    if (final_board[i][j] == final_board[i][j+3]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j+3] != '⬛'and
                                            final_board[i][j+3] != '🌫️' and
                                            final_board[i][j] == final_board[i][j-1]and
                                            final_board[i][j]!= '⬛'and
                                            final_board[i][j]!='🌫️'and
                                            final_board[i][j-1] != '⬛'and
                                            final_board[i][j-1] != '🌫️'):
                                        #print(f' five move found with gem at x: {j+1} y: {i-1}, second gem at {j-1} {i} third gem at {j} {i} fourth {j + 2} {i} fifth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'down',5)
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)

    #print("@@@@@@@@@@@@@@@ 5 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

            if i + 2 < 8:
                if (final_board[i][j] == final_board[i + 2][j]and
                        final_board[i][j]!= '⬛'and
                        final_board[i][j]!='🌫️'and
                        final_board[i + 2][j]!= '⬛'and
                        final_board[i + 2][j]!= '🌫️'):
                    if i + 1 < 8 and j + 1 < 8:
                        if (final_board[i][j] == final_board[i + 1][j + 1]and
                                final_board[i][j]!= '⬛'and
                                final_board[i][j]!='🌫️'and
                                final_board[i + 1][j + 1]!= '⬛'and
                                final_board[i + 1][j + 1]!= '🌫️'):
                            if i + 3 < 8 and i -1 > -1:
                                if (final_board[i][j] == final_board[i + 3][j]and
                                        final_board[i][j]!= '⬛'and
                                        final_board[i][j]!='🌫️'and
                                        final_board[i + 3][j] != '⬛'and
                                        final_board[i + 3][j] != '🌫️' and
                                        final_board[i][j] == final_board[i-1][j]and
                                        final_board[i][j]!= '⬛'and
                                        final_board[i][j]!='🌫️'and
                                        final_board[i-1][j] != '⬛'and
                                        final_board[i-1][j] != '🌫️'):
                                    #print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x: {j} {i+3}')
                                    move = (j + 1,i + 1 ,'left',5)
                                    if move not in moves_to_left:
                                        moves_to_left.append(move)
                    if i + 1 < 8 and j - 1 > -1:
                        if (final_board[i][j] == final_board[i + 1][j - 1]and
                                final_board[i][j]!= '⬛'and
                                final_board[i][j]!='🌫️'and
                                final_board[i + 1][j - 1]!= '⬛'and
                                final_board[i + 1][j - 1]!= '🌫️'):
                            if i + 3 < 8 and i-1 > -1:
                                if (final_board[i][j] == final_board[i + 3][j]and
                                        final_board[i][j]!= '⬛'and
                                        final_board[i][j]!='🌫️'and
                                        final_board[i + 3][j]!= '⬛'and
                                        final_board[i + 3][j]!= '🌫️' and
                                        final_board[i][j] == final_board[i-1][j]and
                                        final_board[i][j]!= '⬛'and
                                        final_board[i][j]!='🌫️'and
                                        final_board[i-1][j] != '⬛'and
                                        final_board[i-1][j] != '🌫️'):
                                    #print(f' five move found with gem at x: {j-1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x {j} {i+3}')
                                    move = (j - 1,i + 1 ,'right',5)
                                    if move not in moves_to_right:
                                        moves_to_right.append(move)

    ##################### RAINBOW ###############################
    for i in range(8):
        for j in range(8):
            if final_board[i][j] == '🌈':
                if i-1 > -1:
                    move = (j,i,'up','R')
                    if move not in moves_to_up:
                        moves_to_up.append(move)
                if i+1 < 8:
                    move = (j,i,'down','R')
                    if move not in moves_to_down:
                        moves_to_down.append(move)
                if j-1 > -1:
                    move = (j,i,'left','R')
                    if move not in moves_to_left:
                        moves_to_left.append(move)
                if i+1 <8:
                    move = (j,i,'right','R')
                    if move not in moves_to_right:
                        moves_to_right.append(move)


    print(f'{bcolors.BOLD} MOVES {bcolors.ENDC}')
    if len(moves_to_left) != 0:
        print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO LEFT: {moves_to_left}')
    if len(moves_to_right) != 0:
        print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO RIGHT: {moves_to_right}')
    if len(moves_to_up) != 0:
        print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO UP: {moves_to_up}')
    if len(moves_to_down) != 0:
        print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO DOWN: {moves_to_down}{bcolors.ENDC}')

    all_moves = []
    for move in moves_to_left:
        all_moves.append(move)
    for move in moves_to_right:
        all_moves.append(move)
    for move in moves_to_up:
        all_moves.append(move)
    for move in moves_to_down:
        all_moves.append(move)
    #print(f'all the moves that will be checked: {all_moves} with lenght of {len(all_moves)}')

    # BIG ISSUE NOW YOU NEED TO OVERWRITE LOWER COMBINATIONS SSINCE IF THE MOVE WILL BE 5GEM AND BOT WWILL TRY TO DO THE 3 MOVE WHICH WOULD GIVE WRONG OUTCOMES!!!!!

    #original = with powered | final = without powered
    return all_moves




    #SCORING AND WRITING BOARD

def sieve_moves(array):
    sieved = []
    to_remove =[]
    for moves in array:
        for moves2 in array:
            if moves[0] == moves2[0] and moves[1] == moves2[1] and moves[2] == moves2[2]:
                print(moves,moves2)
                if moves[3] == '┘r' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┘d' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '└l' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┐u' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┌u' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┐r' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┌l' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '└d' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┝l' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┥r' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┬u' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == '┴d' and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == 4 and moves2[3] == 3:
                    to_remove.append(moves2)
                if moves[3] == 5 and moves2[3] == '4u':
                    to_remove.append(moves2)
                if moves[3] == 5 and moves2[3] == '4d':
                    to_remove.append(moves2)
                if moves[3] == 5 and moves2[3] == '4l':
                    to_remove.append(moves2)
                if moves[3] == 5 and moves2[3] == '4r':
                    to_remove.append(moves2)
                if moves[3] == 5 and moves2[3] == 3:
                    to_remove.append(moves2)
            if moves[1] == moves2[1] and moves[2] == 'left' and moves2[2] == 'right' and moves[3] == moves2[3]:
                if moves[0]-1 == moves2[0]:
                    to_remove.append(moves2)
            if moves[0] == moves2[0] and moves[2] == 'up' and moves2[2] == 'down' and moves[3] == moves2[3]:
                if moves[1]-1 == moves2[1]:
                    to_remove.append(moves2)
            '''if moves[0] == moves2[0] and moves[2] == 'down' and moves2[2] == 'up' and moves[3] == moves2[3]:
                if moves[1]+1 == moves2[1]:
                    to_remove.append(moves)'''
    for move in array:
        if move not in to_remove:
            sieved.append(move)
    #print(to_remove)
    return sieved

'''def calculate_moves(original_board,final_board,all_moves):

    print(f' orig {original_board}')
    boardformoves = copy.deepcopy(original_board)
    rainbow_gems = [] # gems next to rainbow to remove if using rainbow is a good move
    #niszceznie gemow na oryginalnym nboardzie
    no_rainbow = True
    scores_array = []
    for i in range(8):
        if '🌈' in original_board[i]:
            no_rainbow = False
            #niszczenie gemow i pobieranie ich posyzji na zmienionym boardzie gdzie powered gems jest taki sam jak zwykly gem
            for i in range(8):
                for j in range(8):
                    if original_board[i][j] == '🌈':
                        if i-1>-1 and j+1 < 8 and j-1 > -1 and i+1 < 8:
                            print(f'rainbow gem found gems around: {final_board[i-1][j]} {final_board[i+1][j]} {final_board[i][j+1]} {final_board[i][j-1]}')
                        else:
                            print('rainbow next to side board, gems found around:')
                            if i - 1 > -1:
                                print(final_board[i-1][j])
                            if i + 1 < 8:
                                print(final_board[i+1][j])
                            if j + 1 < 8:
                                final_board[i][j + 1]
                            if j - 1 > -1:
                                final_board[i][j - 1]
                        if i-1 > -1:
                            if final_board[i-1][j] not in rainbow_gems and final_board[i-1][j] != "⬛":
                                rainbow_gems.append(final_board[i-1][j])
                        if i+1 < 8:
                            if final_board[i + 1][j] not in rainbow_gems and final_board[i+1][j] != "⬛":
                                rainbow_gems.append(final_board[i+1][j])
                        if j+1 < 8:
                            if final_board[i][j+1] not in rainbow_gems and final_board[i][j+1] != "⬛":
                                rainbow_gems.append(final_board[i][j+1])
                        if j-1 > -1:
                            if final_board[i][j-1] not in rainbow_gems and final_board[i][j-1] != "⬛":
                                rainbow_gems.append(final_board[i][j-1])

            rainbow_gems_1 = [] # position of gem 1 on board to remove
            rainbow_gems_2 = [] # position of gem 2 on board to remove
            rainbow_gems_3 = [] # position of gem 3 on board to remove
            rainbow_gems_4 = [] # position of gem 4 on board to remove
            loop = 0
            print(f'rainbow gems {rainbow_gems}')
            for gem in rainbow_gems:
                loop+=1
                board = copy.deepcopy(final_board)


                for i in range(8):
                    for j in range(8):

                        if board[i][j] == gem:
                            board[i][j] = '⬛'
                            if gem == rainbow_gems[0]:
                                move = (j,i)
                                rainbow_gems_1.append(move)
                            if gem == rainbow_gems[1]:
                                move = (j,i)
                                rainbow_gems_2.append(move)
                            if len(rainbow_gems)>2:
                                if gem == rainbow_gems[2]:
                                    move = (j,i)
                                    rainbow_gems_3.append(move)
                            if len(rainbow_gems) > 3:
                                if gem == rainbow_gems[3]:
                                    move = (j,i)
                                    rainbow_gems_4.append(move)
                print(f'board after using rainbow moves for {gem}')
                for row in board:
                    print(' '.join(row))
                if loop == 1:
                    board_gem_1 = board
                    print(board_gem_1)
                elif loop == 2:
                    board_gem_2 = board
                    print(board_gem_2)
                elif loop == 3:
                    board_gem_3 = board
                    print(board_gem_3)
                elif loop == 4:
                    board_gem_4 = board
                    print(board_gem_4)

                print('-----------------------')

            print(f'board_gem_1 {rainbow_gems[0]}')
            for row in board_gem_1:
                print(' '.join(row))

            print(f'board_gem_2 {rainbow_gems[1]}')
            for row in board_gem_2:
                print(' '.join(row))

            if len(rainbow_gems) > 2:
                print(f'board_gem_3 {rainbow_gems[2]}')
                for row in board_gem_3:
                    print(' '.join(row))

            if len(rainbow_gems) > 3:
                print(f'board_gem_4 {rainbow_gems[3]}')
                for row in board_gem_4:
                    print(' '.join(row))

            print(f' lenght of array 1 (rainbow_gems_1){len(rainbow_gems_1)}')
            print(f' lenght of array 1 (rainbow_gems_2){len(rainbow_gems_2)}')
            if len(rainbow_gems) > 2:
                print(f' lenght of array 1 (rainbow_gems_3){len(rainbow_gems_3)}')
            if len(rainbow_gems) > 3:
                print(f' lenght of array 1 (rainbow_gems_4){len(rainbow_gems_4)}')

            powered_gems_array = ['🟣', '⚪', '🟠', '🔴', '🟢', '🔵', '🟡']
            board2 = copy.deepcopy(original_board)



            for i in range(len(rainbow_gems_1)):

                    if original_board[rainbow_gems_1[i][1]][rainbow_gems_1[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 1 after rainbow move at {rainbow_gems_1[i][0]} {rainbow_gems_1[i][1]}')
                        explode_gem(board2,rainbow_gems_1[i][1],rainbow_gems_1[i][0], 'board 1',board_gem_1)
                    
            scores_array.append(rainbow_gems[0])
            for i in range(len(rainbow_gems_2)):
                    if original_board[rainbow_gems_2[i][1]][rainbow_gems_2[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 2 after rainbow move at {rainbow_gems_2[i][0]} {rainbow_gems_2[i][1]}')
                        explode_gem(board2,rainbow_gems_2[i][1],rainbow_gems_2[i][0],'board 2',board_gem_2)
                    
            scores_array.append(rainbow_gems[1])
            if len(rainbow_gems) > 2:
                for i in range(len(rainbow_gems_3)):
                        if original_board[rainbow_gems_3[i][1]][rainbow_gems_3[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 3  after rainbow move at {rainbow_gems_3[i][0]} {rainbow_gems_3[i][1]}')
                            explode_gem(board2,rainbow_gems_3[i][1],rainbow_gems_3[i][0],'board 3',board_gem_3)
                        
                scores_array.append(rainbow_gems[2])
            #score3 = score

            if len(rainbow_gems) > 3:
                score = 0
                for i in range(len(rainbow_gems_4)):
                        if original_board[rainbow_gems_4[i][1]][rainbow_gems_4[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 4 after rainbow move at {rainbow_gems_4[i][0]} {rainbow_gems_4[i][1]}')
                            explode_gem(board2,rainbow_gems_4[i][1],rainbow_gems_4[i][0],'board 4',board_gem_4)
                        
                scores_array.append(rainbow_gems[3])
            #score4 = score
            #print(f'scores array {scores_array}  rianbow gems {rainbow_gems}')
            print('-----------------------')
            
            for row in board_to_print:
                print(' '.join(row))
    #print(no_rainbow)
    #boardformoves


    if True:
            moves_arr = []
            for moves in all_moves:
                boardformoves = copy.deepcopy(original_board)
                if moves[2] == 'left':

                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1]][moves[0]-1] = boardformoves[moves[1]][moves[0]-1],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    ##recursive function and shit like that
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves,converted_board)
                    print('board for moves after functions')
                    
                elif moves[2] == 'right':
                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1]][moves[0]+1] = boardformoves[moves[1]][moves[0]+1],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    
                    moves_arr.append(moves)
                elif moves[2] == 'down':
                    boardformoves[moves[1]][moves[0]],boardformoves[moves[1]+1][moves[0]] = boardformoves[moves[1]+1][moves[0]],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    
                    moves_arr.append(moves)

                elif moves[2] == 'up':
                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1] - 1][moves[0]] = boardformoves[moves[1] - 1][moves[0]], boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print('---------')
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    
                    moves_arr.append(moves)

            print(moves_arr)

            #print(scores_array)
            for a in scores_array:
                print(a)
                moves_arr.append(a)
            moves_arr = sorted(moves_arr, key=lambda x: x[0], reverse=True)
            print(moves_arr)

            if isinstance(moves_arr[0][1], tuple):
                print(f'move will be made from x: {moves_arr[0][1][0]} y: {moves_arr[0][1][1]} to side: {moves_arr[0][1][2]}')
                make_move(moves_arr[0][1][0],moves_arr[0][1][1],moves_arr[0][1][2])
            else:
                print(moves_arr[0][1])
                gems_and_moves = []
                for i in range(8):
                    for j in range(8):
                        if original_board[j][i] == '🌈':
                            move1 = (original_board[j][i-1],'left')
                            #if move1[1] not in gems_and_moves:
                            gems_and_moves.append(move1)
                            move1 = (original_board[j][i + 1], 'right')
                            gems_and_moves.append(move1)
                            move1 = (original_board[j+1][i], 'down')
                            gems_and_moves.append(move1)
                            move1 = (original_board[j-1][i ], 'up')
                            gems_and_moves.append(move1)
                            pos_on_board = (j,i)
                print(gems_and_moves)
                for move in gems_and_moves:
                    if moves_arr[0][1] == move[0]:
                        print(f' gem {move[1]} pos x:{pos_on_board[1]} pos y:{pos_on_board[0]}')
                        make_move(pos_on_board[1],pos_on_board[0],move[1])
                        break


'''

def array_creation(board_with_powered,board_without_powered):  #creates an array that shows which gems are 3 or more in a row and should be replaced or exploded depending on the gem
    array_with_position_to_replace = []
    for i in range(8):
        for j in range(8):
            if j <= 8 - 5 and tablica[j][i] == tablica[j + 1][i] == \
                    tablica[j + 2][i] == tablica[j + 3][i] == tablica[j + 4][
                i] != "⬛":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i), (j + 4, i)])
            if i <= 8 - 5 and tablica[j][i] == tablica[j][i + 1] == \
                    tablica[j][i + 2] == tablica[j][i + 3] == tablica[j][
                i + 4] != "⬛":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            if j <= 8 - 4 and tablica[j][i] == tablica[j + 1][i] == \
                    tablica[j + 2][i] == tablica[j + 3][i] != "⬛":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i)])
            if i <= 8 - 4 and tablica[j][i] == tablica[j][i + 1] == \
                    tablica[j][i + 2] == tablica[j][i + 3] != "⬛":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3)])
            if j <= 8 - 3 and tablica[j][i] == tablica[j + 1][i] == \
                    tablica[j + 2][i] != "⬛":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i)])
            if i <= 8 - 3 and tablica[j][i] == tablica[j][i + 1] == \
                    tablica[j][i + 2] != "⬛":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2)])
    return array_with_position_to_replace

def check_for_rows(board_with_powered,board_without_powered,move):
    array_with_position_to_replace = []
    print(f'in check for moves, for move {move}')
    for i in range(8):
        for j in range(8):
            if j <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] == board_without_powered[j + 4][
                i] != "⬛" and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] == board_without_powered[j + 4][
                i] !='🌫️':
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i), (j + 4, i)])
            if i <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] == board_without_powered[j][
                i + 4] != "⬛" and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] == board_without_powered[j][
                i + 4]!='🌫️':
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            if j <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] != "⬛" and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] !='🌫️':
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i)])
            if i <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] != "⬛" and  board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] !='🌫️':
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3)])
            if j <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] != "⬛" and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i]!='🌫️':
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i)])
            if i <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] != "⬛" and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] !='🌫️':
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2)])

    #return array_with_position_to_replace
    main_gem = (move[0],move[1])
    print(f'inside checkfor rows main gem {main_gem}')
    powered = ['⚪', '🔴', '🟠', '🟡', '🟢', '🔵', '🟣']
    power_gem_pos = []
    powered_gem_gem = ''


    for group_pos in array_with_position_to_replace:
        for pos in group_pos:
            if board_with_powered[pos[0]][pos[1]] in powered:
                move = (pos[0],pos[1])

                if move not in power_gem_pos:
                    power_gem_pos.append(move)
            print(f'current pos {pos}')
            board_without_powered[pos[0]][pos[1]] = "⬛"
            board_with_powered[pos[0]][pos[1]] = "⬛"
    for row in board_without_powered:
        print(' '.join(row))
    if move[3] == '4r' or move[3] == '4l':
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '🟪': powered_gem_gem = '🟣'
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '🟦': powered_gem_gem = '🔵'
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '🟩': powered_gem_gem = '🟢'
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '🟨': powered_gem_gem = '🟡'
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '🟧': powered_gem_gem = '🟠'
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '🟥': powered_gem_gem = '🔴'
        if board_without_powered[main_gem[1]-1][main_gem[0]] == '⬜': powered_gem_gem = '⚪'
        print(f'powered gem gem{powered_gem_gem}')

        board_with_powered[move[1]+1][move[0]] = powered_gem_gem
        board_without_powered[move[1]+1][move[0]] = powered_gem_gem
    if len(power_gem_pos) == 0:
        score = 0


        #exploding gem
    else:
        print(f'powered gem pos {power_gem_pos}')
        for gems in power_gem_pos:

            throwaway_board = copy.deepcopy(original_board)
            exploded_board = explode_gem(board_with_powered,gems[0],gems[1],'explode gem test',throwaway_board)
            exploded_board_fin = przeskiej(exploded_board)
        print('board with poewered')
        for row in board_with_powered:
                print(' '.join(row))
        print('board without powerred')
        for row in board_without_powered:
                print(' '.join(row))
        print('board exploded')
        for row in exploded_board_fin:
            print(' '.join(row))




    return board_with_powered,board_without_powered

'''def make_moves_function(array):
    for moves in array:
        x1 = moves[0]
        y1 = moves[1]
        str = moves[2]
        width, height = 85 * 8, 84 * 8

        screenshot = ImageGrab.grab(bbox=(318, 66, 318 + width, 68 + height))

        pyautogui.click(350 + x1 * 85, 85 + y1 * 84)
        time.sleep(0.2)
        if str == 'left':
            pyautogui.click(350 + (x1 - 1) * 85, 85 + y1 * 84)
        if str == 'right':
            pyautogui.click(350 + (x1 + 1) * 85, 85 + y1 * 84)
        if str == 'up':
            pyautogui.click(350 + x1 * 85, 85 + (y1 - 1) * 84)
        if str == 'down':
            pyautogui.click(350 + x1 * 85, 85 + (y1 + 1) * 84)
        time.sleep(1)'''

def przesun_czarne_do_gory(tablica):
        wysokosc = len(tablica)
        szerokosc = len(tablica[0])

        for kolumna in range(szerokosc):
            kolumna_tablicy = [tablica[wiersz][kolumna] for wiersz in range(wysokosc)]
            kolumna_bez_czarnych = [blok for blok in kolumna_tablicy if blok != "⬛"]
            kolumna_tablicy = ["⬛"] * (wysokosc - len(kolumna_bez_czarnych)) + kolumna_bez_czarnych

            for wiersz in range(wysokosc):
                tablica[wiersz][kolumna] = kolumna_tablicy[wiersz]

        return tablica

def group_positions(positions):
    groups = []

    for pos in positions:
        added_to_group = False
        for group in groups:
            for group_pos in group:
                if abs(pos[0] - group_pos[0]) <= 1 and abs(pos[1] - group_pos[1]) <= 1:
                    group.append(pos)
                    added_to_group = True
                    break
            if added_to_group:
                break

        if not added_to_group:
            groups.append([pos])
    print(f' groups: {groups}')
    return groups

def explode_gem(board,y,x,strin,board_to_overwrite):
    print(f'board state:')
    score= 0
    gem_exploded = 0
    for row in board:
        print(' '.join(row))
    if board[y][x] == '⬛': return
    board2 = copy.deepcopy(board)
    print(f'{strin}, x:{x}, y:{y} ')
    print('board to voerwrite')
    for row in board_to_overwrite:
        print(' '.join(row))

    print('---------------------')
    pos_of_powered = []
    powered_gems_array = ['🟣', '⚪', '🟠', '🔴', '🟢', '🔵', '🟡']

    for i in range(8):
        for j in range(8):
            if original_board[j][i] in powered_gems_array:
                pos = (i,j)
                pos_of_powered.append(pos)

    print(f'powered gem pos {pos_of_powered}')


    gem_groups =group_positions(pos_of_powered)
    gem = (x,y)
    group_of_gems = [] #chain
    for group in gem_groups:
        if gem in group:
            print(f'gem found in group {group}')
            group_of_gems = group
    print(f' remaining pos {pos}')
    for pos in group_of_gems:
        for i in range(pos[0] - 1, pos[0] + 2):
            for j in range(pos[1] - 1, pos[1] + 2):
                if i > -1 and i < 8 and j > -1 and j < 8:
                    board2[j][i] = '⬛'
        score+=300
        gem_exploded +=1

    print('test score')

    print('state of board after explode')
    for row in board2:
        print(' '.join(row))

    print('state of board after explode with other black places')

    for i in range(8):
        for j in range(8):
            if board2[j][i] == '⬛' or board2[j][i] == '🌈':
                board_to_overwrite[j][i] = '⬛'
    for row in board_to_overwrite:
        print(' '.join(row))
    board2 = original_board
    print('------------------------')
    wynik = przesun_czarne_do_gory(board_to_overwrite)
    for wiersz in wynik:
        print(" ".join(wiersz))
    for i in range(8):
        for j in range(8):
            if board_to_overwrite[j][i] == '⬛':
                score += 100

    print(score - gem_exploded*100)
    return board_to_overwrite

def convert_board(board):
    converted_board = board
    emoji_mapping = {
        '🟧': '🟧',
        '🟨': '🟨',
        '🟦': '🟦',
        '🟩': '🟩',
        '🟪': '🟪',
        '⬜': '⬜',
        '🟥': '🟥',
        '🌈': '🌈',
        '⚪': '⬜',
        '🔵': '🟦',
        '🔴': '🟥',
        '🟣': '🟪',
        '🟢': '🟩',
        '🟠': '🟧',
        '🟡': '🟨',
        '⬛': '⬛',
        '🌫️': '🌫️',
        '🅿️': '⚫'
    }
    for i in range(8):
        for j in range(8):
            gem = board[i][j]
            if gem in emoji_mapping:
                converted_board[i][j] = emoji_mapping[gem]
            else:
                converted_board[i][j] = gem
    for row in converted_board:
        print(' '.join(row))
    return converted_board

'''def next_move(board_p,moves,already_done_moves): DONT REMOVE THIS ONE KINDA WORKS AS A RECURCION, COMMENTED OUT BECAUSE IM WORKING JUST ON NEXT MOVE AND GAME STUFF

    black_board = [['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛']]
    board_not_powered = convert_board(board_p)
    for move in moves:
        already_done = already_done_moves
        print(f' checking for {move}')
        copy_np = copy.deepcopy(board_not_powered)
        copy_p = copy.deepcopy(board_p)
        if move[2] == 'left':
            copy_np[move[1]][move[0]], copy_np[move[1]][move[0] - 1] = copy_np[move[1]][
                move[0] - 1], copy_np[move[1]][move[0]]
            copy_p[move[1]][move[0]], copy_p[move[1]][move[0] - 1] = copy_p[move[1]][
                move[0] - 1], copy_p[move[1]][move[0]]
        if move[2] == 'right' :
            copy_np[move[1]][move[0]], copy_np[move[1]][move[0] + 1] = copy_np[move[1]][
                move[0] + 1], copy_np[move[1]][move[0]]
            copy_p[move[1]][move[0]], copy_p[move[1]][move[0] + 1] = copy_p[move[1]][
                move[0] + 1], copy_p[move[1]][move[0]]
        if move[2] == 'up' :
            copy_np[move[1]][move[0]], copy_np[move[1]-1][move[0]] = copy_np[move[1]-1][
                move[0]], copy_np[move[1]][move[0]]
            copy_p[move[1]][move[0]], copy_p[move[1] -1][move[0]] = copy_p[move[1] - 1][
                move[0]], copy_p[move[1]][move[0]]
        if move[2] == 'down':
            copy_np[move[1]][move[0]], copy_np[move[1]+1][move[0]] = copy_np[move[1]+1][
                move[0]], copy_np[move[1]][move[0]]
            copy_p[move[1]][move[0]], copy_p[move[1] +1][move[0]] = copy_p[move[1] +1][
                move[0]], copy_p[move[1]][move[0]]
        
        for row in copy_np:
            print(' '.join(row))
        print('----------------')

        aftermove_p,aftermove_np = check_for_rows(copy_p,copy_np)
        aftermove_p2 = przesun_czarne_do_gory(aftermove_p)
        aftermove_np2 = przesun_czarne_do_gory(aftermove_np)

        print('powered')
        for row in aftermove_p2:
            print(' '.join(row))
        print('--------------')
        print('not powered')
        for row in aftermove_np2:
            print(' '.join(row))
        print('--------------')
        new_moves = check_for_moves(aftermove_np2)
        print(f'sieved moves{new_moves}')
        if aftermove_np2 == black_board:
            print('this one good ')
            already_done.append(move)
            print(already_done)
            return already_done
        print(f' queue of moves {already_done} remaining moves = {new_moves}')
        if len(new_moves) != 0:
            already_done.append(move)
            result = next_move(aftermove_np2,new_moves,already_done)
            if len(result) !=0:
                return result
        else:
            already_done = []
    return []'''
def next_move(board_p,moves,already_done_moves):
    copy_of_p = copy.deepcopy(board_p)
    black_board = [['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛']]
    board_not_powered = convert_board(copy_of_p)

    for move in moves:

        print('board_p')
        for row in board_p:
            print(' '.join(row))
        bomb_placement = []
        gem = 'g'
        already_done = copy.deepcopy(already_done_moves) #aaaaaaaaaaaaaaaaaa

        #print(f'alredy done moves {already_done_moves}')
        #already_done.append('1')
        print(f'already done {already_done_moves}')
        print(f' checking for {move} already done {already_done} ')
        copy_np = copy.deepcopy(board_not_powered)
        copy_p = copy.deepcopy(board_p)
        for i in range(8):
            for j in range(8):
                try:
                    int(copy_np[i][j])
                    bomb_pos = (i,j)
                    bomb_placement.append(bomb_pos)

                    #print(copy_np[i][j])
                except ValueError:pass
        if move[2] == 'left' :
            if move[3] != 'R':
                copy_np[move[1]][move[0]], copy_np[move[1]][move[0] - 1] = copy_np[move[1]][
                    move[0] - 1], copy_np[move[1]][move[0]]
                copy_p[move[1]][move[0]], copy_p[move[1]][move[0] - 1] = copy_p[move[1]][
                    move[0] - 1], copy_p[move[1]][move[0]]
            elif move[3] == 'R':
                gem = copy_np[move[1]][move[0]-1]
                copy_np[move[1]][move[0]] = '⬛'
                for y in range(8):
                    for x in range(8):
                        if copy_np[x][y]==gem:
                            copy_np[x][y] = '⬛'
        if move[2] == 'right' :
            if move[3] != 'R':
                copy_np[move[1]][move[0]], copy_np[move[1]][move[0] + 1] = copy_np[move[1]][
                    move[0] + 1], copy_np[move[1]][move[0]]
                copy_p[move[1]][move[0]], copy_p[move[1]][move[0] + 1] = copy_p[move[1]][
                    move[0] + 1], copy_p[move[1]][move[0]]
            elif move[3] == 'R':
                gem = copy_np[move[1]][move[0] + 1]
                copy_np[move[1]][move[0]] = '⬛'
                for y in range(8):
                    for x in range(8):
                        if copy_np[x][y] == gem:
                            copy_np[x][y] = '⬛'
        if move[2] == 'up' :
            if move[3] != 'R':
                copy_np[move[1]][move[0]], copy_np[move[1]-1][move[0]] = copy_np[move[1]-1][
                    move[0]], copy_np[move[1]][move[0]]
                copy_p[move[1]][move[0]], copy_p[move[1] -1][move[0]] = copy_p[move[1] - 1][
                    move[0]], copy_p[move[1]][move[0]]
            elif move[3] == 'R':
                gem = copy_np[move[1]-1][move[0]]
                copy_np[move[1]][move[0]] = '⬛'
                for y in range(8):
                    for x in range(8):
                        if copy_np[x][y] == gem:
                            copy_np[x][y] = '⬛'
        if move[2] == 'down':
            if move[3] != 'R':
                copy_np[move[1]][move[0]], copy_np[move[1]+1][move[0]] = copy_np[move[1]+1][
                    move[0]], copy_np[move[1]][move[0]]
                copy_p[move[1]][move[0]], copy_p[move[1] +1][move[0]] = copy_p[move[1] +1][
                    move[0]], copy_p[move[1]][move[0]]
            elif move[3] == 'R':
                gem = copy_np[move[1] + 1][move[0]]
                copy_np[move[1]][move[0]] = '⬛'
                for y in range(8):
                    for x in range(8):
                        if copy_np[x][y] == gem:
                            copy_np[x][y] = '⬛'
        for bombs in bomb_placement:
            value = copy_np[bombs[0]][bombs[1]]
            val2 = int(value)
            val2 -= 1
            string = str(val2)
            copy_np[bombs[0]][bombs[1]] = string
            copy_p[bombs[0]][bombs[1]] = string

        for row in copy_np:
            print(' '.join(row))
        print('----------------')

        for row in copy_p:
            print(' '.join(row))
        print('----------------')

        aftermove_p,aftermove_np = check_for_rows(copy_p,copy_np,move)
        aftermove_p2 = przesun_czarne_do_gory(aftermove_p)
        aftermove_np2 = przesun_czarne_do_gory(aftermove_np)

        '''print('powered')
        for row in aftermove_p2:
            print(' '.join(row))
        print('--------------')'''
        print('not powered')
        for row in aftermove_np2:
            print(' '.join(row))
        print('--------------')
        new_moves = check_for_moves(aftermove_np2)
        print(f'sieved moves{new_moves}')
        #print(f'pre if  queue of moves {already_done} remaining moves = {new_moves}')

        if aftermove_np2 == black_board:
            print('this one good ')
            already_done.append(move)
            print(already_done)
            return already_done # makes the loop not run indefinitely
        print(f' queue of moves {already_done} remaining moves = {new_moves}')
        print(f' remaining moves = {new_moves}')
        if len(new_moves) == 0:
            print('if runs')
            print('reset moves')
            already_done = []
            print(already_done)

        else:
            print('else run')
            #already_done = []
            already_done.append(move)

            result = next_move(aftermove_np2, new_moves, already_done)
            print(f'result {result}')
            if len(result) != 0:

                return result # makes the loop not run indefinitely too fsr?

    return []





#test()
brd = \
    [['⬛', '🟩', '🟪', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '🟪', '🟩', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '🟪', '🟩', '🟥', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '🟥', '🟥', '🟦', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '🟧', '🟩', '🟦', '⬜', '⬛', '⬛', '⬛'],
     ['⬛', '🟪', '🟪', '🟥', '🟪', '⬛', '⬛', '⬛'],
     ['⬛', '🟧', '🟩', '🟦', '🟥', '⬛', '⬛', '⬛'],
     ['⬛', '🟧', '🟩', '⬜', '🟥', '⬜', '⬛', '⬛']]
#🟥🟨🟦🟪⬜🟩🟧
[['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛']]
[['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛', '⬛'],
     ['⬛', '🟩', '🟦', '🟪', '🟥', '🟦', '🟩', '⬛'],
     ['⬛', '🟩', '🟦', '🟪', '🟥', '🟦', '🟩', '⬛'],
     ['⬛', '🟦', '🟩', '🟥', '🟪', '🟩', '🟦', '⬛'],
     ['🟥', '🟧', '🟨', '⬜', '⬜', '🟨', '🟧', '🟥'],
     ['🟥', '🟧', '🟨', '⬜', '⬜', '🟨', '🟧', '🟥'],
     ['🟧', '🟥', '⬜', '🟨', '🟨', '⬜', '🟥', '🟧']]
array_with_moves =check_for_moves(brd)
sieved_moves = sieve_moves(array_with_moves)
print(f'not sieved   {array_with_moves}')
print(f'sieved moves {sieved_moves}')
next_move(brd,sieved_moves,[])
