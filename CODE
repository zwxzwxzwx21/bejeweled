import pyautogui
import time
import numpy as np
import matplotlib.pyplot as plt
from PIL import ImageGrab, Image, ImageEnhance
import cv2
from matplotlib import pyplot as plt
import subprocess
import copy
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

debug = False
start_time =time.time()
#opening the game
subprocess.Popen(["D:\\Bejeweled 2 Deluxe\\Bejeweled2.exe"])
empty_board = [['â¬›' for i in range(8)] for i in range(8)]
#windows title moving to the corner
win = pyautogui.getWindowsWithTitle('Bejeweled 2 Deluxe 1.0')[0]
array_with_cur_moves = []
win.activate()
win.moveTo(0, 0)

wylosowane_kolory = [(199, 22, 199), (225, 225, 55), (230, 220, 220), (255,175,0), (49, 171, 253), (19, 202, 19), (255, 99, 99),(0,0,0),(82, 76, 24),(255,255,255)]
            # in order: pink,               yellow,         white,          orange,      blue,         green,           red
kolory = ['pink','yellow','white','orange','blue','green','red','black','brown','rainbow']
start_pos_x = 318
start_pos_y = 68
#coordinated for drawing dots on image
kordy = []
a = ''
import cProfile
def test():

    x, y = pyautogui.position()
    width, height = 85 * 8, 84 * 8

    screenshot = ImageGrab.grab(bbox=(start_pos_x, start_pos_y, start_pos_x + width, start_pos_y + height))

    plt.imshow(screenshot)
    plt.axis('on')
    plt.show()




    array_color = []
    for i in range(3):

        x, y = start_pos_x, start_pos_y
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))


        colors =[]

        for j in range(8):
            for i in range(8):
                new_x = x + 85 * i + 41
                new_y = y + 84 * j + 42

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))


                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break

        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›',
            'brown': '?',
            'rainbow': 'R'
        }
        color = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color[i][j] = color_mapping[colors[index]]

    for i in range(3):

        x, y = start_pos_x, start_pos_y
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
        #variable to make dots even or something
        t,t2 = 0 , -1
        colors =[]
        for j in range(8):

            for i in range(8):
                t+=1
                if t == 2:
                    t2+=1
                new_x = x + 85 * i + 6 - i + t2 + 2
                new_y = y + 84 * j + 42
                kordy.append((new_x-start_pos_x,new_y-start_pos_y))

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›',
            'brown': 'P',
            'rainbow': 'R'
        }
        color_power = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color_power[i][j] = color_mapping[colors[index]]
        '''for row in color_power:
            print(' '.join(row))'''



    # compare arrays to determine what is what
    first_color_array = []
    second_color_array = []
    for gem in color:
        first_color_array+=gem
    for gem in color_power:
        second_color_array+=gem


    #comparing
    #new array to have new board state
    pre_final_board = []
    for i in range(64):
        if second_color_array[i] == 'P' and first_color_array[i] == 'R':
            pre_final_board.append('âšª')
        elif second_color_array[i] == 'â¬›' and first_color_array[i] == 'R':
            pre_final_board.append('ðŸŒˆ')
        elif first_color_array[i] == 'ðŸŸ¨' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¨')
        elif first_color_array[i] == 'ðŸŸ¥' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¥')
        elif first_color_array[i] == 'ðŸŸ§' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ§')
        elif first_color_array[i] == 'ðŸŸ¦' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¦')
        elif first_color_array[i] == 'ðŸŸ©' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ©')
        elif first_color_array[i] == 'ðŸŸª' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸª')
        elif first_color_array[i] == 'â¬œ' and second_color_array[i] != 'P':
            pre_final_board.append('â¬œ')
        elif first_color_array[i] == 'ðŸŸ¨' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ¡')
        elif first_color_array[i] == 'ðŸŸ¥' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸ”´')
        elif first_color_array[i] == 'ðŸŸ§' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ ')
        elif first_color_array[i] == 'ðŸŸ¦' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸ”µ')
        elif first_color_array[i] == 'ðŸŸ©' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ¢')
        elif first_color_array[i] == 'ðŸŸª' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ£')
        elif first_color_array[i] == 'â¬›' and second_color_array[i] != 'R':
            pre_final_board.append('â¬›')

    # ðŸ”´ðŸŸ ðŸŸ¡ðŸŸ¢ðŸ”µðŸŸ£
    print(f'pre array{pre_final_board}')
    final_board = [['' for _ in range(8)] for _ in range(8)]
    color_mapping = {
        'ðŸŸ¨': 'ðŸŸ¨',
        'ðŸŸ¦': 'ðŸŸ¦',
        'ðŸŸª': 'ðŸŸª',
        'â¬œ': 'â¬œ',
        'ðŸŸ©': 'ðŸŸ©',
        'ðŸŸ§': 'ðŸŸ§',
        'ðŸŸ¥': 'ðŸŸ¥',
        'ðŸ”µ': 'ðŸ”µ',
        'âšª': 'âšª',
        'ðŸŒˆ': 'ðŸŒˆ',
        'ðŸ”´': 'ðŸ”´',
        'ðŸŸ£': 'ðŸŸ£',
        'ðŸŸ¢': 'ðŸŸ¢',
        'ðŸŸ ': 'ðŸŸ ',
        'ðŸŸ¡': 'ðŸŸ¡',
        'â¬›': 'â¬›'
    }

    for i, emoji in enumerate(pre_final_board):
        row = i // 8
        col = i % 8
        final_board[row][col] = color_mapping.get(emoji, 'unknown')


    for row in final_board:
        print(row)
    end_time = time.time()
    print(f' elapsed in seconds:{end_time - start_time}')
    global original_board
    original_board =copy.deepcopy(final_board)
    print(f' orig {original_board}') # dobry
    #convert the board to cound powered gems as normal gems so you can make moves with normal and powered
    converted_board = [['' for _ in range(8)] for _ in range(8)]
    emoji_mapping = {
        'ðŸŸ¨': 'ðŸŸ¨',
        'ðŸŸ¦': 'ðŸŸ¦',
        'ðŸŸ©': 'ðŸŸ©',
        'ðŸŸª': 'ðŸŸª',
        'â¬œ': 'â¬œ',
        'ðŸŸ¥': 'ðŸŸ¥',
        'ðŸŒˆ': 'ðŸŒˆ',
        'âšª': 'â¬œ',
        'ðŸ”µ': 'ðŸŸ¦',
        'ðŸ”´': 'ðŸŸ¥',
        'ðŸŸ£': 'ðŸŸª',
        'ðŸŸ¢': 'ðŸŸ©',
        'ðŸŸ ': 'ðŸŸ§',
        'ðŸŸ¡': 'ðŸŸ¨',
        'â¬›': 'â¬›'
    }
    for i in range(8):
        for j in range(8):
            gem = final_board[i][j]
            if gem in emoji_mapping:
                converted_board[i][j] = emoji_mapping[gem]
            else:
                converted_board[i][j] = gem
    for row in converted_board:
        print(' '.join(row))
    array_with_moves = check_for_moves(converted_board)
    final_moves = []
    a=[]
    b=[]
    print(f' final moves {final_moves}')
    if len(final_moves) == 0:
        print(f' final moves {final_moves}')
        for moves in array_with_moves:
            recursion_moves = []
            print('moveeeer')
            print(moves)
            print(final_moves)
            if type(final_moves) == list:
                print(final_moves)
                print('is list ^')
                if len(final_moves) != 0:break
            final_moves = recursion(original_board, final_board,moves,recursion_moves)
            print('post fun in loop')
            print(final_moves)
            make_moves_function(final_moves)

    print(f' final moves {final_moves}')
    #make_moves_function(final_moves)

def flag_rows(board_without_powered): # flag that checks if boards does have 3-rows or not
    for i in range(8):
        for j in range(8):
            if j <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] == board_without_powered[j + 4][
                i] != "â¬›":
                return True
            elif i <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] == board_without_powered[j][
                i + 4] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            elif j <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] != "â¬›":
                return True
            elif i <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] != "â¬›":
                return True
            elif j <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] != "â¬›":
                return True
            elif i <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] != "â¬›":
                return True
    return False
def convert_board(board):
    board_to_conv = [['' for _ in range(8)] for _ in range(8)]
    emoji_mapping = {
        'ðŸŸ¨': 'ðŸŸ¨',
        'ðŸŸ¦': 'ðŸŸ¦',
        'ðŸŸ©': 'ðŸŸ©',
        'ðŸŸª': 'ðŸŸª',
        'â¬œ': 'â¬œ',
        'ðŸŸ¥': 'ðŸŸ¥',
        'ðŸŒˆ': 'ðŸŒˆ',
        'âšª': 'â¬œ',
        'ðŸ”µ': 'ðŸŸ¦',
        'ðŸ”´': 'ðŸŸ¥',
        'ðŸŸ£': 'ðŸŸª',
        'ðŸŸ¢': 'ðŸŸ©',
        'ðŸŸ ': 'ðŸŸ§',
        'ðŸŸ¡': 'ðŸŸ¨',
        'â¬›': 'â¬›'
    }
    for i in range(8):
        for j in range(8):
            gem = board[i][j]
            if gem in emoji_mapping:
                board_to_conv[i][j] = emoji_mapping[gem]
            else:
                board_to_conv[i][j] = gem
    return board_to_conv


def check_for_moves(final_board):
    horizontal_pair_of_gems = []
    vertical_pair_of_gems = []
    available_vertical_moves = 0

    #moves based off of position of the gem that will create a move, ie. the one that dissapeares after move
    #gem positions will be stored here and off of those arrays moves will be calculated
    moves_to_left = []
    moves_to_right = []
    moves_to_down = []
    moves_to_up = []

    for i in range(8):
        for j in range(7):
            if final_board[i][j] == final_board[i][j + 1]:
                horizontal_pair_of_gems.append(((j,i),(j+1,i)))
    for j in range(8):
        for i in range(7):
            if final_board[i][j] == final_board[i+1][j]:
                vertical_pair_of_gems.append(((j,i),(j,i+1)))


    #print('vertical moves with pair')
    for i in range(len(vertical_pair_of_gems)):
        #try:
            if debug:print(vertical_pair_of_gems[i])
            if debug:print(final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])])

            if (vertical_pair_of_gems[i][0][0])-1 < 0 or (vertical_pair_of_gems[i][0][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the left')



            else:
                if debug:
                    print(f'gem higher 1 and left:{final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0]) - 1, vertical_pair_of_gems[i][0][1] - 1,'right')
                    if move not in moves_to_right:
                        moves_to_right.append(move)


                    available_vertical_moves += 1




            if debug: print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][0][0])-1} {(vertical_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][0][0]) + 1 >7 or (vertical_pair_of_gems[i][0][1])-1  < 0 or (vertical_pair_of_gems[i][0][1]) > 8: # might have errors
                if debug:
                    print('incorrect position for gem 1 higher and 1 to the right')
                    #  print((vertical_pair_of_gems[i][0][0]) + 1,(vertical_pair_of_gems[i][0][1])-1)




            else:
                if debug:
                    print(f' gem higher 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0])+1,(vertical_pair_of_gems[i][0][1])-1,'left')
                    if move not in moves_to_left:

                        moves_to_left.append(move)
                    available_vertical_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the right{(vertical_pair_of_gems[i][0][0]) + 1} {(vertical_pair_of_gems[i][0][1]-1)}{bcolors.ENDC}')



            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1])-2 < 0:
                if debug:
                    print('incorrect position for gem 2 higher')




            else:

                if debug:print(f' gem higher by 2:{final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]}') # nad parÄ…



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])] != 'â¬›':

                    available_vertical_moves += 1

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 HIGHER{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0]),(vertical_pair_of_gems[i][0][1])-2,'down')
                    if move not in moves_to_down:

                        moves_to_down.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 higher {(vertical_pair_of_gems[i][0][0])} {(vertical_pair_of_gems[i][0][1]) - 2}{bcolors.ENDC}')

            if debug:print('------------')


    for i in range(len(vertical_pair_of_gems)):

            if debug:print(vertical_pair_of_gems[i])
            if debug:print(final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])])

            if (vertical_pair_of_gems[i][1][0])-1 < 0 or (vertical_pair_of_gems[i][1][1])+1 > 7:

                if debug:print('incorrect position for gem 1 lower and 1 to the left')



            else:

                if debug:print(f'gem lower 1 and left:{final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 LEFT{bcolors.ENDC}')

                    move = ((vertical_pair_of_gems[i][1][0])-1,(vertical_pair_of_gems[i][1][1])+1,'right')
                    if move not in moves_to_right:
                        moves_to_right.append(move)
                    available_vertical_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][1][0])-1} {(vertical_pair_of_gems[i][1][1])+1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][1][0]) + 1 >7 or (vertical_pair_of_gems[i][1][1])+1  > 7 or (vertical_pair_of_gems[i][1][1]) > 8: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the right')
                #print((vertical_pair_of_gems[i][1][0]) + 1,(vertical_pair_of_gems[i][1][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 RIGHT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][1][0])+1,(vertical_pair_of_gems[i][1][1])+1,'left')
                    if move not in moves_to_left:

                        moves_to_left.append(move)

                    available_vertical_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the righT {(vertical_pair_of_gems[i][1][0]) + 1} {(vertical_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')



            if (vertical_pair_of_gems[i][1][0]) < 0 or (vertical_pair_of_gems[i][1][1])+2 > 7:

                if debug:print('incorrect position for gem 2 lower')




            else:

                if debug:print(f' gem lower by 2:{final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][1][0])]}') # pod parÄ…



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])] != 'â¬›':

                    available_vertical_moves += 1

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 lower{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][1][0]),(vertical_pair_of_gems[i][1][1])+2,'up')
                    if move not in moves_to_up:

                        moves_to_up.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 lower {(vertical_pair_of_gems[i][1][0])} {(vertical_pair_of_gems[i][1][1]) + 2}{bcolors.ENDC}')

            if debug:print('------------')


    print(f'{bcolors.OKBLUE}VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')

    #HORIZONTAL EASY MOVES
    #print('horizontal moves with pair')
    available_horizontal_moves = 0
    #print(f'################ HORIZONTAL MOVES #####################')
    for i in range(len(horizontal_pair_of_gems)):
        #try:
            if debug:print(horizontal_pair_of_gems[i])
            if debug:print(final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])])

            if (horizontal_pair_of_gems[i][0][0])-1 < 0 or (horizontal_pair_of_gems[i][0][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the left')



            else:

                if debug:print(f'gem higher 1 and left:{final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])-1,'down')
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen 1 higher on the left {(horizontal_pair_of_gems[i][0][0])-1} {(horizontal_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][0][0]) - 1 <0 or (horizontal_pair_of_gems[i][0][1])+1  > 7 or (horizontal_pair_of_gems[i][0][1]) > 8: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the left')
                if debug:print((horizontal_pair_of_gems[i][0][0]) - 1,(horizontal_pair_of_gems[i][0][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the left: {final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])+1,'up')
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the left{(horizontal_pair_of_gems[i][0][0]) - 1} {(horizontal_pair_of_gems[i][0][1]+1)}{bcolors.ENDC}')


            if (horizontal_pair_of_gems[i][0][0])-2 < 0 or (horizontal_pair_of_gems[i][0][1]) < 0:

                if debug:print('incorrect position for gem 2 to left')




            else:

                if debug:print(f' gem left  by 2:{final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2] == final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] != 'â¬›':

                    available_horizontal_moves += 1

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-2,(horizontal_pair_of_gems[i][0][1]),'right')
                    if move not in moves_to_right:

                        moves_to_right.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 to left {(horizontal_pair_of_gems[i][0][0])-2} {(horizontal_pair_of_gems[i][0][1])}{bcolors.ENDC}')

            if debug:print('------------')


    for i in range(len(horizontal_pair_of_gems)):
        #try:
            if debug:print(horizontal_pair_of_gems[i])
            if debug:print(final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])])

            if (horizontal_pair_of_gems[i][1][0])+1 > 7 or (horizontal_pair_of_gems[i][1][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the right')



            else:

                if debug:print(f'gem higher 1 and right:{final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])-1,'down')
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen 1 higher on the right {(horizontal_pair_of_gems[i][1][0])+1} {(horizontal_pair_of_gems[i][1][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][1][0]) + 1 > 7 or (horizontal_pair_of_gems[i][1][1])+1  > 7: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the right')
                if debug:print((horizontal_pair_of_gems[i][1][0]) + 1,(horizontal_pair_of_gems[i][1][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the right: {final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1] != 'â¬›':

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])+1,'up')
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the right{(horizontal_pair_of_gems[i][1][0]) + 1} {(horizontal_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')


            if (horizontal_pair_of_gems[i][1][0])+2 > 7 or (horizontal_pair_of_gems[i][1][1]) < 0:

                if debug:print('incorrect position for gem 2 to right')




            else:

                if debug:print(f' gem right  by 2:{final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2] == final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] != 'â¬›':

                    available_horizontal_moves += 1

                    #print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+2,(horizontal_pair_of_gems[i][1][1]),'left')
                    if move not in moves_to_left:

                        moves_to_left.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 to right {(horizontal_pair_of_gems[i][1][0])+2} {(horizontal_pair_of_gems[i][1][1])}{bcolors.ENDC}')

            if debug:print('------------')


    print(f'{bcolors.OKBLUE}HORIZONTAL MOVES: {available_horizontal_moves}{bcolors.ENDC}')
    #print('horizontal moves with empty middle')

    #checking for moves that would be 2 in same row and 1 higher/lower/left/right but in the middle in general
    for i in range(8):
        for j in range(8):
            try:
                if j + 2 < 8:
                    pass
                else:pass

                if final_board[i][j] == final_board[i][j+2]  != 'â¬›':
                    if i+1 < 8 and j+1 < 8:
                        if final_board[i][j] == final_board[i+1][j+1] != 'â¬›':
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'up')
                            if move not in moves_to_up:

                                moves_to_up.append(move)


                    if i-1 > -1 and j+1 < 8:
                        if final_board[i][j] == final_board[i-1][j+1] != 'â¬›':
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            print(f'move found with gem at x: {j+1} y: {i-1}')
                            move = (j+1,i-1,'down')
                            if move not in moves_to_down:

                                moves_to_down.append(move)

            except:pass
    #same but vertical
    #print('vertical  moves with empty middle')

    for i in range(8):
        for j in range(8):
            try:
                if i + 2 < 8:
                    pass
                else:pass
                if final_board[i][j] == final_board[i+2][j] != 'â¬›':
                    if i+1 < 8 and j+1 < 8:
                        if final_board[i][j] == final_board[i+1][j+1]  != 'â¬›':
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'left')
                            if move not in moves_to_left:
                                moves_to_left.append(move)
                    if i+1 < 8 and j-1 > -1:
                        if final_board[i][j] == final_board[i+1][j-1] != 'â¬›':
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            print(f'move found with gem at x: {j-1} y: {i+1}')
                            move = ( j - 1,i + 1,'right')
                            if move not in moves_to_right:

                                moves_to_right.append(move)

            except:pass

    #print('############ MOVES BY 4 ###############')
    #moves by 4!!! horizontal
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if final_board[i][j] == final_board[i][j + 2] != 'â¬›': # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1] != 'â¬›':
                                if j+3 < 8:
                                    if final_board[i][j] == final_board[i][j+3] != 'â¬›':
                                        move = (j+1,i+1,'up')
                                        if move not in moves_to_up:

                                            moves_to_up.append(move)

                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j+2} {i} fourth gem at x: {j+3} {i}')
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1] != 'â¬›':
                                if j+3 < 8:
                                    if final_board[i][j] == final_board[i][j+3] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j + 2} {i} fourth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'down')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1] != 'â¬›':
                                if j-1 > -1:
                                    if final_board[i][j] == final_board[i][j - 1] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j+2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i - 1,'down')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1] != 'â¬›':
                                if j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j - 1] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j + 2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i + 1,'up')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)

    #vertical;
    #print("@@@@@@@@@@@@@@@ 4 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

           if i + 2 < 8:
                if final_board[i][j] == final_board[i+2][j] != 'â¬›':

                        if i+1 < 8 and j+1 < 8:
                            if final_board[i][j] == final_board[i+1][j+1] != 'â¬›' :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i+3][j] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j + 1,i + 1 ,'left')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)
                        if i+1 < 8 and j-1 > -1:
                            if final_board[i][j] == final_board[i+1][j-1] != 'â¬›' :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i+3][j] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j-1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j - 1,i + 1 ,'right')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                        if j-1 > -1 and i+1 < 8 and i -1 > -1 :
                            if final_board[i][j] == final_board[i+1][j-1] != 'â¬›' :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i - 1][j] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j - 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j - 1,i + 1,'right')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                        if i+1 < 8 and j+1 < 8 and i -1 > -1 :
                            if final_board[i][j] == final_board[i+1][j+1] != 'â¬›' :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i-1][j] != 'â¬›':
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j + 1,i + 1,'left')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)






    #print('$$$$$$$$$$$$$$ MOVES BY 5 $$$$$$$$$$$$$$$$$')
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if final_board[i][j] == final_board[i][j + 2] != 'â¬›': # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1] != 'â¬›':
                                if j+3 < 8 and j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j+3] != 'â¬›' and final_board[i][j] == final_board[i][j-1] != 'â¬›' :
                                        print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j-1} {i}  third gem at {j} {i} fourth {j+2} {i} fifth gem at x: {j+3} {i}')
                                        move = (j + 1,i + 1,'up')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1] != 'â¬›':
                                if j+3 < 8 and j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j+3] != 'â¬›' and final_board[i][j] == final_board[i][j-1] != 'â¬›':
                                        print(f' five move found with gem at x: {j+1} y: {i-1}, second gem at {j-1} {i} third gem at {j} {i} fourth {j + 2} {i} fifth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'down')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)



    #print("@@@@@@@@@@@@@@@ 5 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

            if i + 2 < 8:
                if final_board[i][j] == final_board[i + 2][j] != 'â¬›':

                    if i + 1 < 8 and j + 1 < 8:
                        if final_board[i][j] == final_board[i + 1][j + 1] != 'â¬›':
                            if i + 3 < 8 and i -1 > -1:
                                if final_board[i][j] == final_board[i + 3][j] != 'â¬›' and final_board[i][j] == final_board[i-1][j] != 'â¬›':
                                    print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x: {j} {i+3}')
                                    move = (j + 1,i + 1 ,'left')
                                    if move not in moves_to_left:
                                        moves_to_left.append(move)
                    if i + 1 < 8 and j - 1 > -1:
                        if final_board[i][j] == final_board[i + 1][j - 1]:
                            if i + 3 < 8 and i-1 > -1:
                                if final_board[i][j] == final_board[i + 3][j] != 'â¬›' and final_board[i][j] == final_board[i-1][j] != 'â¬›':

                                    print(f' five move found with gem at x: {j-1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x {j} {i+3}')
                                    move = (j - 1,i + 1 ,'right')
                                    if move not in moves_to_right:
                                        moves_to_right.append(move)



    print(f'{bcolors.BOLD} MOVES {bcolors.ENDC}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO LEFT: {moves_to_left}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO RIGHT: {moves_to_right}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO UP: {moves_to_up}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO DOWN: {moves_to_down}{bcolors.ENDC}')

    all_moves = []
    for move in moves_to_left:
        all_moves.append(move)
    for move in moves_to_right:
        all_moves.append(move)
    for move in moves_to_up:
        all_moves.append(move)
    for move in moves_to_down:
        all_moves.append(move)
    #print(f'all the moves that will be checked: {all_moves} with lenght of {len(all_moves)}')



    #original = with powered | final = without powered
    return all_moves




    #SCORING AND WRITING BOARD
'''def recursion (powered_board, board, move, array_with_cur_moves):
    should_return = False
    print('-Srecursion-')
    print('powered')
    for row in powered_board:
        print(' '.join(row))
    print('board')
    for row in board:
        print(' '.join(row))
    print(move)
    print(f' array with cur moves{array_with_cur_moves}')
    print(f'cheching for move: {move}')
    '''




'''def calculate_moves(original_board,final_board,all_moves):

    print(f' orig {original_board}')
    boardformoves = copy.deepcopy(original_board)
    rainbow_gems = [] # gems next to rainbow to remove if using rainbow is a good move
    #niszceznie gemow na oryginalnym nboardzie
    no_rainbow = True
    scores_array = []
    for i in range(8):
        if 'ðŸŒˆ' in original_board[i]:
            no_rainbow = False
            #niszczenie gemow i pobieranie ich posyzji na zmienionym boardzie gdzie powered gems jest taki sam jak zwykly gem
            for i in range(8):
                for j in range(8):
                    if original_board[i][j] == 'ðŸŒˆ':
                        if i-1>-1 and j+1 < 8 and j-1 > -1 and i+1 < 8:
                            print(f'rainbow gem found gems around: {final_board[i-1][j]} {final_board[i+1][j]} {final_board[i][j+1]} {final_board[i][j-1]}')
                        else:
                            print('rainbow next to side board, gems found around:')
                            if i - 1 > -1:
                                print(final_board[i-1][j])
                            if i + 1 < 8:
                                print(final_board[i+1][j])
                            if j + 1 < 8:
                                final_board[i][j + 1]
                            if j - 1 > -1:
                                final_board[i][j - 1]
                        if i-1 > -1:
                            if final_board[i-1][j] not in rainbow_gems and final_board[i-1][j] != "â¬›":
                                rainbow_gems.append(final_board[i-1][j])
                        if i+1 < 8:
                            if final_board[i + 1][j] not in rainbow_gems and final_board[i+1][j] != "â¬›":
                                rainbow_gems.append(final_board[i+1][j])
                        if j+1 < 8:
                            if final_board[i][j+1] not in rainbow_gems and final_board[i][j+1] != "â¬›":
                                rainbow_gems.append(final_board[i][j+1])
                        if j-1 > -1:
                            if final_board[i][j-1] not in rainbow_gems and final_board[i][j-1] != "â¬›":
                                rainbow_gems.append(final_board[i][j-1])

            rainbow_gems_1 = [] # position of gem 1 on board to remove
            rainbow_gems_2 = [] # position of gem 2 on board to remove
            rainbow_gems_3 = [] # position of gem 3 on board to remove
            rainbow_gems_4 = [] # position of gem 4 on board to remove
            loop = 0
            print(f'rainbow gems {rainbow_gems}')
            for gem in rainbow_gems:
                loop+=1
                board = copy.deepcopy(final_board)


                for i in range(8):
                    for j in range(8):

                        if board[i][j] == gem:
                            board[i][j] = 'â¬›'
                            if gem == rainbow_gems[0]:
                                move = (j,i)
                                rainbow_gems_1.append(move)
                            if gem == rainbow_gems[1]:
                                move = (j,i)
                                rainbow_gems_2.append(move)
                            if len(rainbow_gems)>2:
                                if gem == rainbow_gems[2]:
                                    move = (j,i)
                                    rainbow_gems_3.append(move)
                            if len(rainbow_gems) > 3:
                                if gem == rainbow_gems[3]:
                                    move = (j,i)
                                    rainbow_gems_4.append(move)
                print(f'board after using rainbow moves for {gem}')
                for row in board:
                    print(' '.join(row))
                if loop == 1:
                    board_gem_1 = board
                    print(board_gem_1)
                elif loop == 2:
                    board_gem_2 = board
                    print(board_gem_2)
                elif loop == 3:
                    board_gem_3 = board
                    print(board_gem_3)
                elif loop == 4:
                    board_gem_4 = board
                    print(board_gem_4)

                print('-----------------------')

            print(f'board_gem_1 {rainbow_gems[0]}')
            for row in board_gem_1:
                print(' '.join(row))

            print(f'board_gem_2 {rainbow_gems[1]}')
            for row in board_gem_2:
                print(' '.join(row))

            if len(rainbow_gems) > 2:
                print(f'board_gem_3 {rainbow_gems[2]}')
                for row in board_gem_3:
                    print(' '.join(row))

            if len(rainbow_gems) > 3:
                print(f'board_gem_4 {rainbow_gems[3]}')
                for row in board_gem_4:
                    print(' '.join(row))

            print(f' lenght of array 1 (rainbow_gems_1){len(rainbow_gems_1)}')
            print(f' lenght of array 1 (rainbow_gems_2){len(rainbow_gems_2)}')
            if len(rainbow_gems) > 2:
                print(f' lenght of array 1 (rainbow_gems_3){len(rainbow_gems_3)}')
            if len(rainbow_gems) > 3:
                print(f' lenght of array 1 (rainbow_gems_4){len(rainbow_gems_4)}')

            powered_gems_array = ['ðŸŸ£', 'âšª', 'ðŸŸ ', 'ðŸ”´', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ¡']
            board2 = copy.deepcopy(original_board)



            for i in range(len(rainbow_gems_1)):

                    if original_board[rainbow_gems_1[i][1]][rainbow_gems_1[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 1 after rainbow move at {rainbow_gems_1[i][0]} {rainbow_gems_1[i][1]}')
                        explode_gem(board2,rainbow_gems_1[i][1],rainbow_gems_1[i][0], 'board 1',board_gem_1)
                    
            scores_array.append(rainbow_gems[0])
            for i in range(len(rainbow_gems_2)):
                    if original_board[rainbow_gems_2[i][1]][rainbow_gems_2[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 2 after rainbow move at {rainbow_gems_2[i][0]} {rainbow_gems_2[i][1]}')
                        explode_gem(board2,rainbow_gems_2[i][1],rainbow_gems_2[i][0],'board 2',board_gem_2)
                    
            scores_array.append(rainbow_gems[1])
            if len(rainbow_gems) > 2:
                for i in range(len(rainbow_gems_3)):
                        if original_board[rainbow_gems_3[i][1]][rainbow_gems_3[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 3  after rainbow move at {rainbow_gems_3[i][0]} {rainbow_gems_3[i][1]}')
                            explode_gem(board2,rainbow_gems_3[i][1],rainbow_gems_3[i][0],'board 3',board_gem_3)
                        
                scores_array.append(rainbow_gems[2])
            #score3 = score

            if len(rainbow_gems) > 3:
                score = 0
                for i in range(len(rainbow_gems_4)):
                        if original_board[rainbow_gems_4[i][1]][rainbow_gems_4[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 4 after rainbow move at {rainbow_gems_4[i][0]} {rainbow_gems_4[i][1]}')
                            explode_gem(board2,rainbow_gems_4[i][1],rainbow_gems_4[i][0],'board 4',board_gem_4)
                        
                scores_array.append(rainbow_gems[3])
            #score4 = score
            #print(f'scores array {scores_array}  rianbow gems {rainbow_gems}')
            print('-----------------------')
            
            for row in board_to_print:
                print(' '.join(row))
    #print(no_rainbow)
    #boardformoves


    if True:
            moves_arr = []
            for moves in all_moves:
                boardformoves = copy.deepcopy(original_board)
                if moves[2] == 'left':

                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1]][moves[0]-1] = boardformoves[moves[1]][moves[0]-1],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    ##recursive function and shit like that
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves,converted_board)
                    print('board for moves after functions')
                    
                elif moves[2] == 'right':
                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1]][moves[0]+1] = boardformoves[moves[1]][moves[0]+1],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    
                    moves_arr.append(moves)
                elif moves[2] == 'down':
                    boardformoves[moves[1]][moves[0]],boardformoves[moves[1]+1][moves[0]] = boardformoves[moves[1]+1][moves[0]],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    
                    moves_arr.append(moves)

                elif moves[2] == 'up':
                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1] - 1][moves[0]] = boardformoves[moves[1] - 1][moves[0]], boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print('---------')
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    
                    moves_arr.append(moves)

            print(moves_arr)

            #print(scores_array)
            for a in scores_array:
                print(a)
                moves_arr.append(a)
            moves_arr = sorted(moves_arr, key=lambda x: x[0], reverse=True)
            print(moves_arr)

            if isinstance(moves_arr[0][1], tuple):
                print(f'move will be made from x: {moves_arr[0][1][0]} y: {moves_arr[0][1][1]} to side: {moves_arr[0][1][2]}')
                make_move(moves_arr[0][1][0],moves_arr[0][1][1],moves_arr[0][1][2])
            else:
                print(moves_arr[0][1])
                gems_and_moves = []
                for i in range(8):
                    for j in range(8):
                        if original_board[j][i] == 'ðŸŒˆ':
                            move1 = (original_board[j][i-1],'left')
                            #if move1[1] not in gems_and_moves:
                            gems_and_moves.append(move1)
                            move1 = (original_board[j][i + 1], 'right')
                            gems_and_moves.append(move1)
                            move1 = (original_board[j+1][i], 'down')
                            gems_and_moves.append(move1)
                            move1 = (original_board[j-1][i ], 'up')
                            gems_and_moves.append(move1)
                            pos_on_board = (j,i)
                print(gems_and_moves)
                for move in gems_and_moves:
                    if moves_arr[0][1] == move[0]:
                        print(f' gem {move[1]} pos x:{pos_on_board[1]} pos y:{pos_on_board[0]}')
                        make_move(pos_on_board[1],pos_on_board[0],move[1])
                        break


'''
def array_creation(board_with_powered,board_without_powered):  #creates an array that shows which gems are 3 or more in a row and should be replaced or exploded depending on the gem
    array_with_position_to_replace = []
    for i in range(8):
        for j in range(8):
            if j <= 8 - 5 and tablica[j][i] == tablica[j + 1][i] == \
                    tablica[j + 2][i] == tablica[j + 3][i] == tablica[j + 4][
                i] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i), (j + 4, i)])
            if i <= 8 - 5 and tablica[j][i] == tablica[j][i + 1] == \
                    tablica[j][i + 2] == tablica[j][i + 3] == tablica[j][
                i + 4] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            if j <= 8 - 4 and tablica[j][i] == tablica[j + 1][i] == \
                    tablica[j + 2][i] == tablica[j + 3][i] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i)])
            if i <= 8 - 4 and tablica[j][i] == tablica[j][i + 1] == \
                    tablica[j][i + 2] == tablica[j][i + 3] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3)])
            if j <= 8 - 3 and tablica[j][i] == tablica[j + 1][i] == \
                    tablica[j + 2][i] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i)])
            if i <= 8 - 3 and tablica[j][i] == tablica[j][i + 1] == \
                    tablica[j][i + 2] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2)])
    return array_with_position_to_replace

def check_for_rows(board_with_powered,board_without_powered):
    array_with_position_to_replace = []
    for i in range(8):
        for j in range(8):
            if j <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] == board_without_powered[j + 4][
                i] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i), (j + 4, i)])
            if i <= 8 - 5 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] == board_without_powered[j][
                i + 4] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            if j <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] == board_without_powered[j + 3][i] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i)])
            if i <= 8 - 4 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] == board_without_powered[j][i + 3] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3)])
            if j <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j + 1][i] == \
                    board_without_powered[j + 2][i] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i)])
            if i <= 8 - 3 and board_without_powered[j][i] == board_without_powered[j][i + 1] == \
                    board_without_powered[j][i + 2] != "â¬›":
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2)])
    #return array_with_position_to_replace
    powered = ['âšª', 'ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£']
    power_gem_pos = []
    for group_pos in array_with_position_to_replace:
        for pos in group_pos:
            if board_with_powered[pos[0]][pos[1]] in powered:
                move = (pos[0],pos[1])
                if move not in power_gem_pos:
                    power_gem_pos.append(move)
            board_without_powered[pos[0]][pos[1]] = "â¬›"
    if len(power_gem_pos) == 0:
        score = 0


        #exploding gem
    else:
        print(f'powered gem pos {power_gem_pos}')
        for gems in power_gem_pos:

            throwaway_board = copy.deepcopy(original_board)
            exploded_board = explode_gem(board_with_powered,gems[0],gems[1],'explode gem test',throwaway_board)
            exploded_board_fin = przeskiej(exploded_board)
        print('board with poewered')
        for row in board_with_powered:
                print(' '.join(row))
        print('board without powerred')
        for row in board_without_powered:
                print(' '.join(row))
        print('board exploded')
        for row in exploded_board_fin:
            print(' '.join(row))



    #return score

    return board_with_powered,board_without_powered
def make_moves_function(array):
    '''for moves in array:
        x1 = moves[0]
        y1 = moves[1]
        str = moves[2]
        width, height = 85 * 8, 84 * 8

        screenshot = ImageGrab.grab(bbox=(318, 66, 318 + width, 68 + height))

        pyautogui.click(350 + x1 * 85, 85 + y1 * 84)
        time.sleep(0.2)
        if str == 'left':
            pyautogui.click(350 + (x1 - 1) * 85, 85 + y1 * 84)
        if str == 'right':
            pyautogui.click(350 + (x1 + 1) * 85, 85 + y1 * 84)
        if str == 'up':
            pyautogui.click(350 + x1 * 85, 85 + (y1 - 1) * 84)
        if str == 'down':
            pyautogui.click(350 + x1 * 85, 85 + (y1 + 1) * 84)
        time.sleep(1)'''

def przesun_czarne_do_gory(tablica):
        wysokosc = len(tablica)
        szerokosc = len(tablica[0])

        for kolumna in range(szerokosc):
            kolumna_tablicy = [tablica[wiersz][kolumna] for wiersz in range(wysokosc)]
            kolumna_bez_czarnych = [blok for blok in kolumna_tablicy if blok != "â¬›"]
            kolumna_tablicy = ["â¬›"] * (wysokosc - len(kolumna_bez_czarnych)) + kolumna_bez_czarnych

            for wiersz in range(wysokosc):
                tablica[wiersz][kolumna] = kolumna_tablicy[wiersz]






        return tablica
'''def make_move(x1,y1,str):
    print(x1)
    print(str)
    print(y1)
    return

    pyautogui.click(350+x1*85,85+y1*84)
    time.sleep(0.1)
    if str == 'left':
        pyautogui.click(350 + (x1-1) * 85, 85 + y1 * 84)
    if str == 'right':
        pyautogui.click(350 + (x1+1) * 85, 85 + y1 * 84)
    if str == 'up':
        pyautogui.click(350 + x1 * 85, 85 + (y1-1) * 84)
    if str == 'down':
        pyautogui.click(350 + x1 * 85, 85 + (y1+1) * 84)




def przesun_czarne_do_gory(tablica):
        wysokosc = len(tablica)
        szerokosc = len(tablica[0])

        for kolumna in range(szerokosc):
            kolumna_tablicy = [tablica[wiersz][kolumna] for wiersz in range(wysokosc)]
            kolumna_bez_czarnych = [blok for blok in kolumna_tablicy if blok != "â¬›"]
            kolumna_tablicy = ["â¬›"] * (wysokosc - len(kolumna_bez_czarnych)) + kolumna_bez_czarnych

            for wiersz in range(wysokosc):
                tablica[wiersz][kolumna] = kolumna_tablicy[wiersz]

        return tablica


def group_positions(positions):
    groups = []

    for pos in positions:
        added_to_group = False
        for group in groups:
            for group_pos in group:
                if abs(pos[0] - group_pos[0]) <= 1 and abs(pos[1] - group_pos[1]) <= 1:
                    group.append(pos)
                    added_to_group = True
                    break
            if added_to_group:
                break

        if not added_to_group:
            groups.append([pos])
    print(f' groups: {groups}')
    return groups'''


def explode_gem(board,y,x,strin,board_to_overwrite):
    print(f'board state:')
    score= 0
    gem_exploded = 0
    for row in board:
        print(' '.join(row))
    if board[y][x] == 'â¬›': return
    board2 = copy.deepcopy(board)
    print(f'{strin}, x:{x}, y:{y} ')
    print('board to voerwrite')
    for row in board_to_overwrite:
        print(' '.join(row))

    print('---------------------')
    pos_of_powered = []
    powered_gems_array = ['ðŸŸ£', 'âšª', 'ðŸŸ ', 'ðŸ”´', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ¡']

    for i in range(8):
        for j in range(8):
            if original_board[j][i] in powered_gems_array:
                pos = (i,j)
                pos_of_powered.append(pos)

    print(f'powered gem pos {pos_of_powered}')


    gem_groups =group_positions(pos_of_powered)
    gem = (x,y)
    group_of_gems = [] #chain
    for group in gem_groups:
        if gem in group:
            print(f'gem found in group {group}')
            group_of_gems = group
    print(f' remaining pos {pos}')
    for pos in group_of_gems:
        for i in range(pos[0] - 1, pos[0] + 2):
            for j in range(pos[1] - 1, pos[1] + 2):
                if i > -1 and i < 8 and j > -1 and j < 8:
                    board2[j][i] = 'â¬›'
        score+=300
        gem_exploded +=1

    print('test score')

    print('state of board after explode')
    for row in board2:
        print(' '.join(row))

    print('state of board after explode with other black places')

    for i in range(8):
        for j in range(8):
            if board2[j][i] == 'â¬›' or board2[j][i] == 'ðŸŒˆ':
                board_to_overwrite[j][i] = 'â¬›'
    for row in board_to_overwrite:
        print(' '.join(row))
    board2 = original_board
    print('------------------------')
    wynik = przesun_czarne_do_gory(board_to_overwrite)
    for wiersz in wynik:
        print(" ".join(wiersz))
    for i in range(8):
        for j in range(8):
            if board_to_overwrite[j][i] == 'â¬›':
                score += 100

    print(score - gem_exploded*100)
    return board_to_overwrite

cProfile.run('test()')
test()
