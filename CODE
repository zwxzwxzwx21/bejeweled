import pyautogui
import time
import numpy as np
import matplotlib.pyplot as plt
from PIL import ImageGrab, Image, ImageEnhance
import cv2
from matplotlib import pyplot as plt
import subprocess
import copy
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
debug = False
start_time =time.time()
#opening the game
subprocess.Popen(["D:\\Bejeweled 2 Deluxe\\Bejeweled2.exe"])

#windows title moving to the corner
win = pyautogui.getWindowsWithTitle('Bejeweled 2 Deluxe 1.0')[0]

win.activate()
win.moveTo(0, 0)



#(82, 76, 24),
wylosowane_kolory = [(199, 22, 199), (225, 225, 55), (230, 220, 220), (255,175,0), (49, 171, 253), (19, 202, 19), (255, 99, 99),(0,0,0),(82, 76, 24),(255,255,255)]
            # in order: pink,               yellow,         white,          orange,      blue,         green,           red
kolory = ['pink','yellow','white','orange','blue','green','red','black','brown','rainbow']


timer = 0
#coordinated for drawing dots on image
kordy = []
a = ''
import cProfile
def test():

    x, y = pyautogui.position()
    width, height = 85 * 8, 84 * 8

    screenshot = ImageGrab.grab(bbox=(305, 62, 305 + width, 62 + height))


    plt.imshow(screenshot)
    plt.axis('on')  # WyÅ‚Ä…cz osie
    plt.show()




    array_color = []
    for i in range(3):

        x, y = 305, 62
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

        #print(aktualny_kolor)
        #print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):
            for i in range(8):
                new_x = x + 85 * i + 41
                new_y = y + 84 * j + 42

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                #print(aktualny_kolor)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

                #print(najblizszy_kolor)
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        #print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ğŸŸª',
            'yellow': 'ğŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ğŸŸ§',
            'blue': 'ğŸŸ¦',
            'green': 'ğŸŸ©',
            'red': 'ğŸŸ¥',
            'black': 'â¬›',
            'brown': '?',
            'rainbow': 'R'
        }
        color = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color[i][j] = color_mapping[colors[index]]
        #for row in color:
            #print(' '.join(row))
        #print(color)
    #print(array_color)
    for i in range(3):

        x, y = 305, 62
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
        #variable to make dots even or something
        t,t2 = 0 , -1
        #print(aktualny_kolor)
        #print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):

            for i in range(8):
                t+=1
                if t == 2:
                    t2+=1
                new_x = x + 85 * i + 6 - i + t2 + 2
                new_y = y + 84 * j + 42
                kordy.append((new_x-305,new_y-62))

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                #print(aktualny_kolor)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
                #print(najblizszy_kolor)
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        #print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ğŸŸª',
            'yellow': 'ğŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ğŸŸ§',
            'blue': 'ğŸŸ¦',
            'green': 'ğŸŸ©',
            'red': 'ğŸŸ¥',
            'black': 'â¬›',
            'brown': 'P',
            'rainbow': 'R'
        }
        color_power = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color_power[i][j] = color_mapping[colors[index]]
        for row in color_power:
            print(' '.join(row))
        #print(f' [color_power]= {color_power}')
    #print(array_color)
    #print(len(kordy))
    #print(kordy)


    # compare arrays to determine what is what
    first_color_array = []
    second_color_array = []
    for gem in color:
        first_color_array+=gem
    #print(first_color_array)
    for gem in color_power:
        second_color_array+=gem


    #comparing
    #new array to have new board state
    pre_final_board = []
    for i in range(64):
        if second_color_array[i] == 'P' and first_color_array[i] == 'R':
            pre_final_board.append('âšª')
        elif second_color_array[i] == 'â¬›' and first_color_array[i] == 'R':
            pre_final_board.append('ğŸŒˆ')
        elif first_color_array[i] == 'ğŸŸ¨' and second_color_array[i] != 'P':
            pre_final_board.append('ğŸŸ¨')
        elif first_color_array[i] == 'ğŸŸ¥' and second_color_array[i] != 'P':
            pre_final_board.append('ğŸŸ¥')
        elif first_color_array[i] == 'ğŸŸ§' and second_color_array[i] != 'P':
            pre_final_board.append('ğŸŸ§')
        elif first_color_array[i] == 'ğŸŸ¦' and second_color_array[i] != 'P':
            pre_final_board.append('ğŸŸ¦')
        elif first_color_array[i] == 'ğŸŸ©' and second_color_array[i] != 'P':
            pre_final_board.append('ğŸŸ©')
        elif first_color_array[i] == 'ğŸŸª' and second_color_array[i] != 'P':
            pre_final_board.append('ğŸŸª')
        elif first_color_array[i] == 'â¬œ' and second_color_array[i] != 'P':
            pre_final_board.append('â¬œ')
        elif first_color_array[i] == 'ğŸŸ¨' and second_color_array[i] == 'P':
            pre_final_board.append('ğŸŸ¡')
        elif first_color_array[i] == 'ğŸŸ¥' and second_color_array[i] == 'P':
            pre_final_board.append('ğŸ”´')
        elif first_color_array[i] == 'ğŸŸ§' and second_color_array[i] == 'P':
            pre_final_board.append('ğŸŸ ')
        elif first_color_array[i] == 'ğŸŸ¦' and second_color_array[i] == 'P':
            pre_final_board.append('ğŸ”µ')
        elif first_color_array[i] == 'ğŸŸ©' and second_color_array[i] == 'P':
            pre_final_board.append('ğŸŸ¢')
        elif first_color_array[i] == 'ğŸŸª' and second_color_array[i] == 'P':
            pre_final_board.append('ğŸŸ£')
    # ğŸ”´ğŸŸ ğŸŸ¡ğŸŸ¢ğŸ”µğŸŸ£
    print(f'pre array{pre_final_board}')
    final_board = [['' for _ in range(8)] for _ in range(8)]
    color_mapping = {
        'ğŸŸ¨': 'ğŸŸ¨',
        'ğŸŸ¦': 'ğŸŸ¦',
        'ğŸŸª': 'ğŸŸª',
        'â¬œ': 'â¬œ',
        'ğŸŸ©': 'ğŸŸ©',
        'ğŸŸ§': 'ğŸŸ§',
        'ğŸŸ¥': 'ğŸŸ¥',
        'ğŸ”µ': 'ğŸ”µ',
        'âšª': 'âšª',
        'ğŸŒˆ': 'ğŸŒˆ',
        'ğŸ”´': 'ğŸ”´',
        'ğŸŸ£': 'ğŸŸ£',
        'ğŸŸ¢': 'ğŸŸ¢',
        'ğŸŸ ': 'ğŸŸ ',
        'ğŸŸ¡': 'ğŸŸ¡',
    }

    for i, emoji in enumerate(pre_final_board):
        row = i // 8
        col = i % 8
        final_board[row][col] = color_mapping.get(emoji, 'unknown')

    # WyÅ›wietlenie ramki final_board
    for row in final_board:
        print(row)
    end_time = time.time()
    print(f' elapsed in seconds:{end_time - start_time}')
    global original_board
    original_board =copy.deepcopy(final_board)
    print(f' orig {original_board}') # dobry
    #convert the board to cound powered gems as normal gems so you can make moves with normal and powered
    converted_board = [['' for _ in range(8)] for _ in range(8)]
    emoji_mapping = {
        'ğŸŸ¨': 'ğŸŸ¨',  # yellow
        'ğŸŸ¦': 'ğŸŸ¦',  # blue
        'ğŸŸ©': 'ğŸŸ©',  # green
        'ğŸŸª': 'ğŸŸª',  # purple
        'â¬œ': 'â¬œ',  # white
        'ğŸŸ¥': 'ğŸŸ¥',  # red
        'ğŸŒˆ': 'ğŸŒˆ',  # rainbow
        'âšª': 'â¬œ',  # white circle
        'ğŸ”µ': 'ğŸŸ¦',  # blue circle -> blue square
        'ğŸ”´': 'ğŸŸ¥',  # red circle -> red square
        'ğŸŸ£': 'ğŸŸª',  # purple circle -> purple square
        'ğŸŸ¢': 'ğŸŸ©',  # green circle -> green square
        'ğŸŸ ': 'ğŸŸ§',  # orange
        'ğŸŸ¡': 'ğŸŸ¨'  # yellow circle -> yellow square
    }
    for i in range(8):
        for j in range(8):
            gem = final_board[i][j]
            if gem in emoji_mapping:
                converted_board[i][j] = emoji_mapping[gem]
            else:
                converted_board[i][j] = gem
    for row in converted_board:
        print(' '.join(row))
    check_for_moves(converted_board)
def convert_board(board):
    board_to_conv = [['' for _ in range(8)] for _ in range(8)]
    emoji_mapping = {
        'ğŸŸ¨': 'ğŸŸ¨',  # yellow
        'ğŸŸ¦': 'ğŸŸ¦',  # blue
        'ğŸŸ©': 'ğŸŸ©',  # green
        'ğŸŸª': 'ğŸŸª',  # purple
        'â¬œ': 'â¬œ',  # white
        'ğŸŸ¥': 'ğŸŸ¥',  # red
        'ğŸŒˆ': 'ğŸŒˆ',  # rainbow
        'âšª': 'â¬œ',  # white circle
        'ğŸ”µ': 'ğŸŸ¦',  # blue circle -> blue square
        'ğŸ”´': 'ğŸŸ¥',  # red circle -> red square
        'ğŸŸ£': 'ğŸŸª',  # purple circle -> purple square
        'ğŸŸ¢': 'ğŸŸ©',  # green circle -> green square
        'ğŸŸ ': 'ğŸŸ§',  # orange
        'ğŸŸ¡': 'ğŸŸ¨'  # yellow circle -> yellow square
    }
    for i in range(8):
        for j in range(8):
            gem = board[i][j]
            if gem in emoji_mapping:
                board_to_conv[i][j] = emoji_mapping[gem]
            else:
                board_to_conv[i][j] = gem
    return board_to_conv


def check_for_moves(final_board):
    horizontal_pair_of_gems = []
    vertical_pair_of_gems = []
    available_vertical_moves = 0

    #moves based off of position of the gem that will create a move, ie. the one that dissapeares after move
    #gem positions will be stored here and off of those arrays moves will be calculated
    moves_to_left = []
    moves_to_right = []
    moves_to_down = []
    moves_to_up = []

    for i in range(8):
        for j in range(7):
            if final_board[i][j] == final_board[i][j + 1]:
                horizontal_pair_of_gems.append(((j,i),(j+1,i)))
    for j in range(8):
        for i in range(7):
            if final_board[i][j] == final_board[i+1][j]:
                vertical_pair_of_gems.append(((j,i),(j,i+1)))
    print('vertical pairs:')
    print(vertical_pair_of_gems)
    print('horizontal pairs:')
    print(horizontal_pair_of_gems)

    print('vertical moves with pair')
    for i in range(len(vertical_pair_of_gems)):
        #try:
            if debug:print(vertical_pair_of_gems[i])
            if debug:print(final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])])

            if (vertical_pair_of_gems[i][0][0])-1 < 0 or (vertical_pair_of_gems[i][0][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the left')



            else:
                if debug:
                    print(f'gem higher 1 and left:{final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0]) - 1, vertical_pair_of_gems[i][0][1] - 1,'right')
                    if move not in moves_to_right:
                        moves_to_right.append(move)


                    available_vertical_moves += 1




            if debug: print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][0][0])-1} {(vertical_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][0][0]) + 1 >7 or (vertical_pair_of_gems[i][0][1])-1  < 0 or (vertical_pair_of_gems[i][0][1]) > 8: # might have errors
                if debug:
                    print('incorrect position for gem 1 higher and 1 to the right')
                    #  print((vertical_pair_of_gems[i][0][0]) + 1,(vertical_pair_of_gems[i][0][1])-1)




            else:
                if debug:
                    print(f' gem higher 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0])+1,(vertical_pair_of_gems[i][0][1])-1,'left')
                    if move not in moves_to_left:

                        moves_to_left.append(move)
                    available_vertical_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the right{(vertical_pair_of_gems[i][0][0]) + 1} {(vertical_pair_of_gems[i][0][1]-1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1])-2 < 0:
                if debug:
                    print('incorrect position for gem 2 higher')




            else:

                if debug:print(f' gem higher by 2:{final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]}') # nad parÄ…



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]:

                    available_vertical_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 HIGHER{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0]),(vertical_pair_of_gems[i][0][1])-2,'down')
                    if move not in moves_to_down:

                        moves_to_down.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 higher {(vertical_pair_of_gems[i][0][0])} {(vertical_pair_of_gems[i][0][1]) - 2}{bcolors.ENDC}')

            if debug:print('------------')


    for i in range(len(vertical_pair_of_gems)):
        #try:
            print(vertical_pair_of_gems[i])
            if debug:print(final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])])

            if (vertical_pair_of_gems[i][1][0])-1 < 0 or (vertical_pair_of_gems[i][1][1])+1 > 7:

                if debug:print('incorrect position for gem 1 lower and 1 to the left')



            else:

                if debug:print(f'gem lower 1 and left:{final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 LEFT{bcolors.ENDC}')

                    move = ((vertical_pair_of_gems[i][1][0])-1,(vertical_pair_of_gems[i][1][1])+1,'right')
                    if move not in moves_to_right:
                        moves_to_right.append(move)
                    available_vertical_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][1][0])-1} {(vertical_pair_of_gems[i][1][1])+1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][1][0]) + 1 >7 or (vertical_pair_of_gems[i][1][1])+1  > 7 or (vertical_pair_of_gems[i][1][1]) > 8: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the right')
                #print((vertical_pair_of_gems[i][1][0]) + 1,(vertical_pair_of_gems[i][1][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 RIGHT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][1][0])+1,(vertical_pair_of_gems[i][1][1])+1,'left')
                    if move not in moves_to_left:

                        moves_to_left.append(move)

                    available_vertical_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the righT {(vertical_pair_of_gems[i][1][0]) + 1} {(vertical_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (vertical_pair_of_gems[i][1][0]) < 0 or (vertical_pair_of_gems[i][1][1])+2 > 7:

                if debug:print('incorrect position for gem 2 lower')




            else:

                if debug:print(f' gem lower by 2:{final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][1][0])]}') # pod parÄ…



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])]:

                    available_vertical_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 lower{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][1][0]),(vertical_pair_of_gems[i][1][1])+2,'up')
                    if move not in moves_to_up:

                        moves_to_up.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 lower {(vertical_pair_of_gems[i][1][0])} {(vertical_pair_of_gems[i][1][1]) + 2}{bcolors.ENDC}')

            if debug:print('------------')


    #print(f'{bcolors.FAIL} VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')
    print(f'{bcolors.OKBLUE}VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')

    #HORIZONTAL EASY MOVES
    print('horizontal moves with pair')
    available_horizontal_moves = 0
    print(f'################ HORIZONTAL MOVES #####################')
    for i in range(len(horizontal_pair_of_gems)):
        #try:
            print(horizontal_pair_of_gems[i])
            if debug:print(final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])])

            if (horizontal_pair_of_gems[i][0][0])-1 < 0 or (horizontal_pair_of_gems[i][0][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the left')



            else:

                if debug:print(f'gem higher 1 and left:{final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])-1,'down')
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen 1 higher on the left {(horizontal_pair_of_gems[i][0][0])-1} {(horizontal_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][0][0]) - 1 <0 or (horizontal_pair_of_gems[i][0][1])+1  > 7 or (horizontal_pair_of_gems[i][0][1]) > 8: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the left')
                if debug:print((horizontal_pair_of_gems[i][0][0]) - 1,(horizontal_pair_of_gems[i][0][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the left: {final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])+1,'up')
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the left{(horizontal_pair_of_gems[i][0][0]) - 1} {(horizontal_pair_of_gems[i][0][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (horizontal_pair_of_gems[i][0][0])-2 < 0 or (horizontal_pair_of_gems[i][0][1]) < 0:

                if debug:print('incorrect position for gem 2 to left')




            else:

                if debug:print(f' gem left  by 2:{final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2] == final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]:

                    available_horizontal_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-2,(horizontal_pair_of_gems[i][0][1]),'right')
                    if move not in moves_to_right:

                        moves_to_right.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 to left {(horizontal_pair_of_gems[i][0][0])-2} {(horizontal_pair_of_gems[i][0][1])}{bcolors.ENDC}')

            if debug:print('------------')


    for i in range(len(horizontal_pair_of_gems)):
        #try:
            print(horizontal_pair_of_gems[i])
            if debug:print(final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])])

            if (horizontal_pair_of_gems[i][1][0])+1 > 7 or (horizontal_pair_of_gems[i][1][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the right')



            else:

                if debug:print(f'gem higher 1 and right:{final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])-1,'down')
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen 1 higher on the right {(horizontal_pair_of_gems[i][1][0])+1} {(horizontal_pair_of_gems[i][1][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][1][0]) + 1 > 7 or (horizontal_pair_of_gems[i][1][1])+1  > 7: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the right')
                if debug:print((horizontal_pair_of_gems[i][1][0]) + 1,(horizontal_pair_of_gems[i][1][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the right: {final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])+1,'up')
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the right{(horizontal_pair_of_gems[i][1][0]) + 1} {(horizontal_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (horizontal_pair_of_gems[i][1][0])+2 > 7 or (horizontal_pair_of_gems[i][1][1]) < 0:

                if debug:print('incorrect position for gem 2 to right')




            else:

                if debug:print(f' gem right  by 2:{final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2] == final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]:

                    available_horizontal_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+2,(horizontal_pair_of_gems[i][1][1]),'left')
                    if move not in moves_to_left:

                        moves_to_left.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 to right {(horizontal_pair_of_gems[i][1][0])+2} {(horizontal_pair_of_gems[i][1][1])}{bcolors.ENDC}')

            if debug:print('------------')


    print(f'{bcolors.OKBLUE}HORIZONTAL MOVES: {available_horizontal_moves}{bcolors.ENDC}')
    print('horizontal moves with empty middle')

    #checking for moves that would be 2 in same row and 1 higher/lower/left/right but in the middle in general
    for i in range(8):
        for j in range(8):
            try:
                if j + 2 < 8:
                    pass#print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j+2}, y2: {i}')
                else:pass
                    #print(f'incorrect position found at x: {j}')
                if final_board[i][j] == final_board[i][j+2]:
                    if i+1 < 8 and j+1 < 8:
                        if final_board[i][j] == final_board[i+1][j+1] :
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'up')
                            if move not in moves_to_up:

                                moves_to_up.append(move)


                    if i-1 > -1 and j+1 < 8:
                        if final_board[i][j] == final_board[i-1][j+1]:
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            print(f'move found with gem at x: {j+1} y: {i-1}')
                            move = (j+1,i-1,'down')
                            if move not in moves_to_down:

                                moves_to_down.append(move)

            except:pass
    #same but vertical
    print('vertical  moves with empty middle')

    for i in range(8):
        for j in range(8):
            try:
                if i + 2 < 8:
                    pass
                    #print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i+2][j]} x2: {j}, y2: {i+2}')
                else:pass
                    #print(f'incorrect position found at x: {j}')
                if final_board[i][j] == final_board[i+2][j]:
                    if i+1 < 8 and j+1 < 8:
                        if final_board[i][j] == final_board[i+1][j+1] :
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'left')
                            if move not in moves_to_left:
                                moves_to_left.append(move)
                    if i+1 < 8 and j-1 > -1:
                        if final_board[i][j] == final_board[i+1][j-1]:
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            print(f'move found with gem at x: {j-1} y: {i+1}')
                            move = ( j - 1,i + 1,'right')
                            if move not in moves_to_right:

                                moves_to_right.append(move)

            except:pass

    print('############ MOVES BY 4 ###############')
    #moves by 4!!! horizontal
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if final_board[i][j] == final_board[i][j + 2]: # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1]:
                                if j+3 < 8:
                                    if final_board[i][j] == final_board[i][j+3]:
                                        move = (j+1,i+1,'up')
                                        if move not in moves_to_up:

                                            moves_to_up.append(move)

                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j+2} {i} fourth gem at x: {j+3} {i}')
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1]:
                                if j+3 < 8:
                                    if final_board[i][j] == final_board[i][j+3]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j + 2} {i} fourth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'down')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1]:
                                if j-1 > -1:
                                    if final_board[i][j] == final_board[i][j - 1]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j+2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i - 1,'down')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1]:
                                if j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j - 1]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j + 2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i + 1,'up')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)

    #vertical;
    print("@@@@@@@@@@@@@@@ 4 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

           if i + 2 < 8:
                if final_board[i][j] == final_board[i+2][j]:

                        if i+1 < 8 and j+1 < 8:
                            if final_board[i][j] == final_board[i+1][j+1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i+3][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j + 1,i + 1 ,'left')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)
                        if i+1 < 8 and j-1 > -1:
                            if final_board[i][j] == final_board[i+1][j-1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i+3][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j-1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j - 1,i + 1 ,'right')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                        if j-1 > -1 and i+1 < 8 and i -1 > -1 :
                            if final_board[i][j] == final_board[i+1][j-1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i - 1][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j - 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j - 1,i + 1,'right')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                        if i+1 < 8 and j+1 < 8 and i -1 > -1 :
                            if final_board[i][j] == final_board[i+1][j+1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i-1][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j + 1,i + 1,'left')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)

                        '''if i+1 < 8 and j-1 > -1:
                            if final_board[i][j] == final_board[i+1][j-1]:
                                print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')
    
                                print(f'move found with gem at x: {j-1} y: {i+1}')'''





    print('$$$$$$$$$$$$$$ MOVES BY 5 $$$$$$$$$$$$$$$$$')
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if final_board[i][j] == final_board[i][j + 2]: # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1]:
                                if j+3 < 8 and j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j+3] and final_board[i][j] == final_board[i][j-1] :
                                        print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j-1} {i}  third gem at {j} {i} fourth {j+2} {i} fifth gem at x: {j+3} {i}')
                                        move = (j + 1,i + 1,'up')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1]:
                                if j+3 < 8 and j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j+3] and final_board[i][j] == final_board[i][j-1]:
                                        print(f' five move found with gem at x: {j+1} y: {i-1}, second gem at {j-1} {i} third gem at {j} {i} fourth {j + 2} {i} fifth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'down')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)



    print("@@@@@@@@@@@@@@@ 5 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

            if i + 2 < 8:
                if final_board[i][j] == final_board[i + 2][j]:

                    if i + 1 < 8 and j + 1 < 8:
                        if final_board[i][j] == final_board[i + 1][j + 1]:
                            if i + 3 < 8 and i -1 > -1:
                                if final_board[i][j] == final_board[i + 3][j] and final_board[i][j] == final_board[i-1][j]:
                                    print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x: {j} {i+3}')
                                    move = (j + 1,i + 1 ,'left')
                                    if move not in moves_to_left:
                                        moves_to_left.append(move)
                    if i + 1 < 8 and j - 1 > -1:
                        if final_board[i][j] == final_board[i + 1][j - 1]:
                            if i + 3 < 8 and i-1 > -1:
                                if final_board[i][j] == final_board[i + 3][j] and final_board[i][j] == final_board[i-1][j]:

                                    print(f' five move found with gem at x: {j-1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x {j} {i+3}')
                                    move = (j - 1,i + 1 ,'right')
                                    if move not in moves_to_right:
                                        moves_to_right.append(move)



    print(f'{bcolors.BOLD} MOVES {bcolors.ENDC}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO LEFT: {moves_to_left}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO RIGHT: {moves_to_right}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO UP: {moves_to_up}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO DOWN: {moves_to_down}{bcolors.ENDC}')

    all_moves = []
    for move in moves_to_left:
        all_moves.append(move)
    for move in moves_to_right:
        all_moves.append(move)
    for move in moves_to_up:
        all_moves.append(move)
    for move in moves_to_down:
        all_moves.append(move)
    calculate_moves(original_board,final_board,all_moves)




    #SCORING AND WRITING BOARD

def check_for_rows(board_with_powered,board_without_powered):
    #check for 3in a row on x axis
    array_with_position_to_replace = []
    for i in range(8):
        for j in range(8):
            if j <= 8-5 and board_without_powered[j][i] == board_without_powered[j+1][i] == board_without_powered[j+2][i] == board_without_powered[j+3][i] == board_with_powered[j+4][i]:
                array_with_position_to_replace.append([(j,i),(j+1,i),(j+2,i),(j+3,i),(j+4,i)])
            if i <= 8-5 and board_without_powered[j][i] == board_without_powered[j][i+1] == board_without_powered[j][i+2] == board_without_powered[j][i+3] == board_without_powered[j][i+4]:
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3), (j, i + 4)])
            if j <= 8-4 and board_without_powered[j][i] == board_without_powered[j+1][i] == board_without_powered[j+2][i] == board_without_powered[j+3][i]:
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i), (j + 3, i)])
            if i <= 8-4 and board_without_powered[j][i] == board_without_powered[j][i+1] == board_without_powered[j][i+2] == board_without_powered[j][i+3]:
                array_with_position_to_replace.append([(j, i), (j, i + 1), (j, i + 2), (j, i + 3)])
            if j <= 8-3 and board_without_powered[j][i] == board_without_powered[j+1][i] == board_without_powered[j+2][i]:
                array_with_position_to_replace.append([(j, i), (j + 1, i), (j + 2, i)])
            if i <= 8-3 and board_without_powered[j][i] == board_without_powered[j][i+1] == board_without_powered[j][i+2]:
                array_with_position_to_replace.append([(j, i), (j , i+1), (j , i+2) ])
    print(array_with_position_to_replace)
    powered = ['âšª', 'ğŸ”´', 'ğŸŸ ', 'ğŸŸ¡', 'ğŸŸ¢', 'ğŸ”µ', 'ğŸŸ£']
    power_gem_pos = []
    for group_pos in array_with_position_to_replace:
        for pos in group_pos:
            if board_with_powered[pos[0]][pos[1]] in powered:
                move = (pos[0],pos[1])
                if move not in power_gem_pos:
                    power_gem_pos.append(move)
            board_without_powered[pos[0]][pos[1]] = "â¬›"
    if len(power_gem_pos) == 0:
        score = 0
        print('board with poewered')
        for row in board_with_powered:
            print(' '.join(row))
        print('board without powerred')
        for row in board_without_powered:
            print(' '.join(row))

        #exploding gem
    else:
        print(f'powered gem pos {power_gem_pos}')
        for gems in power_gem_pos:
            if gems[0] - 1 > -1 and gems[1] + 1 < 8:
                board_without_powered[gems[0]-1][gems[1]+1] = "â¬›"
            if gems[0] + 1 <  8 and gems[1] + 1 < 8:
                board_without_powered[gems[0] + 1][gems[1] + 1] = "â¬›"
            if                      gems[1] + 1 < 8:
                board_without_powered[gems[0]][gems[1]+1] = "â¬›"
            if gems[0] - 1 > -1:
                board_without_powered[gems[0]-1][gems[1]] = "â¬›"
            if gems[0] + 1 <  8:
                board_without_powered[gems[0]+1][gems[1]] = "â¬›"
            if gems[0] + 1 <  8 and gems[1] - 1 > -1:
                board_without_powered[gems[0]+1][gems[1]-1] = "â¬›"
            if                      gems[1] - 1 > -1:
                board_without_powered[gems[0]][gems[1]-1] = "â¬›"
            if gems[0] - 1 > -1 and gems[1] - 1 > -1:
                board_without_powered[gems[0]-1][gems[1]-1] = "â¬›"
        score = 200
        print('board with poewered')
        for row in board_with_powered:
                print(' '.join(row))
        print('board without powerred')
        for row in board_without_powered:
                print(' '.join(row))
    for i in range(8):
            for j in range(8):
                if board_without_powered[i][j] == "â¬›":
                    score += 100
    return score

def make_move(x1,y1,str):
    print(x1)
    print(str)
    print(y1)
    #width, height = 85 * 8, 84 * 8

    #screenshot = ImageGrab.grab(bbox=(305, 62, 305 + width, 62 + height))

    pyautogui.click(350+x1*85,85+y1*84)
    time.sleep(0.1)
    if str == 'left':
        pyautogui.click(350 + (x1-1) * 85, 85 + y1 * 84)
    if str == 'right':
        pyautogui.click(350 + (x1+1) * 85, 85 + y1 * 84)
    if str == 'up':
        pyautogui.click(350 + x1 * 85, 85 + (y1-1) * 84)
    if str == 'down':
        pyautogui.click(350 + x1 * 85, 85 + (y1+1) * 84)


def calculate_moves(original_board,final_board,all_moves):

    print(f' orig {original_board}')
    boardformoves = copy.deepcopy(original_board)
    rainbow_gems = [] # gems next to rainbow to remove if using rainbow is a good move
    #niszceznie gemow na oryginalnym nboardzie
    no_rainbow = True
    scores_array = []
    for i in range(8):
        if 'ğŸŒˆ' in original_board[i]:
            no_rainbow = False
            #niszczenie gemow i pobieranie ich posyzji na zmienionym boardzie gdzie powered gems jest taki sam jak zwykly gem
            for i in range(8):
                for j in range(8):
                    if original_board[i][j] == 'ğŸŒˆ':
                        if i-1>-1 and j+1 < 8 and j-1 > -1 and i+1 < 8:
                            print(f'rainbow gem found gems around: {final_board[i-1][j]} {final_board[i+1][j]} {final_board[i][j+1]} {final_board[i][j-1]}')
                        else:
                            print('rainbow next to side board, gems found around:')
                            if i - 1 > -1:
                                print(final_board[i-1][j])
                            if i + 1 < 8:
                                print(final_board[i+1][j])
                            if j + 1 < 8:
                                final_board[i][j + 1]
                            if j - 1 > -1:
                                final_board[i][j - 1]
                        if i-1 > -1:
                            if final_board[i-1][j] not in rainbow_gems:
                                rainbow_gems.append(final_board[i-1][j])
                        if i+1 < 8:
                            if final_board[i + 1][j] not in rainbow_gems:
                                rainbow_gems.append(final_board[i+1][j])
                        if j+1 < 8:
                            if final_board[i][j+1] not in rainbow_gems:
                                rainbow_gems.append(final_board[i][j+1])
                        if j-1 > -1:
                            if final_board[i][j-1] not in rainbow_gems:
                                rainbow_gems.append(final_board[i][j-1])

            rainbow_gems_1 = [] # position of gem 1 on board to remove
            rainbow_gems_2 = [] # position of gem 2 on board to remove
            rainbow_gems_3 = [] # position of gem 3 on board to remove
            rainbow_gems_4 = [] # position of gem 4 on board to remove
            loop = 0
            print(f'rainbow gems {rainbow_gems}')
            for gem in rainbow_gems:
                loop+=1
                board = copy.deepcopy(final_board)


                for i in range(8):
                    for j in range(8):

                        if board[i][j] == gem or board[i][j] == 'ğŸŒˆ':         # MAYBE BUGS????????????????????????????????????????????????? comment or..ğŸŒˆ if yes

                            board[i][j] = 'â¬›'
                            if gem == rainbow_gems[0]:
                                move = (j,i)
                                rainbow_gems_1.append(move)
                            if gem == rainbow_gems[1]:
                                move = (j,i)
                                rainbow_gems_2.append(move)
                            if len(rainbow_gems)>2:
                                if gem == rainbow_gems[2]:
                                    move = (j,i)
                                    rainbow_gems_3.append(move)
                            if len(rainbow_gems) > 3:
                                if gem == rainbow_gems[3]:
                                    move = (j,i)
                                    rainbow_gems_4.append(move)
                print(f'board after using rainbow moves for {gem}')
                for row in board:
                    print(' '.join(row))
                if loop == 1:
                    board_gem_1 = board
                    print(board_gem_1)
                elif loop == 2:
                    board_gem_2 = board
                    print(board_gem_2)
                elif loop == 3:
                    board_gem_3 = board
                    print(board_gem_3)
                elif loop == 4:
                    board_gem_4 = board
                    print(board_gem_4)

                print('-----------------------')

            print(f'board_gem_1 {rainbow_gems[0]}')
            for row in board_gem_1:
                print(' '.join(row))

            print(f'board_gem_2 {rainbow_gems[1]}')
            for row in board_gem_2:
                print(' '.join(row))

            if len(rainbow_gems) > 2:
                print(f'board_gem_3 {rainbow_gems[2]}')
                for row in board_gem_3:
                    print(' '.join(row))

            if len(rainbow_gems) > 3:
                print(f'board_gem_4 {rainbow_gems[3]}')
                for row in board_gem_4:
                    print(' '.join(row))

            print(f' lenght of array 1 (rainbow_gems_1){len(rainbow_gems_1)}')
            print(f' lenght of array 1 (rainbow_gems_2){len(rainbow_gems_2)}')
            if len(rainbow_gems) > 2:
                print(f' lenght of array 1 (rainbow_gems_3){len(rainbow_gems_3)}')
            if len(rainbow_gems) > 3:
                print(f' lenght of array 1 (rainbow_gems_4){len(rainbow_gems_4)}')

            powered_gems_array = ['ğŸŸ£', 'âšª', 'ğŸŸ ', 'ğŸ”´', 'ğŸŸ¢', 'ğŸ”µ', 'ğŸŸ¡']
            board2 = copy.deepcopy(original_board)



            for i in range(len(rainbow_gems_1)):

                    if original_board[rainbow_gems_1[i][1]][rainbow_gems_1[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 1 after rainbow move at {rainbow_gems_1[i][0]} {rainbow_gems_1[i][1]}')
                        explode_gem(board2,rainbow_gems_1[i][1],rainbow_gems_1[i][0], 'board 1',board_gem_1)
                    else:
                        score = 0
                        for i in range(8):
                            for j in range(8):
                                if board_gem_1[j][i] == 'â¬›':
                                    score += 100
            print(f'score 1 {score}')
            score1 = score
            asdf = ( score,rainbow_gems[0])
            scores_array.append(asdf)
            for i in range(len(rainbow_gems_2)):
                    if original_board[rainbow_gems_2[i][1]][rainbow_gems_2[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 2 after rainbow move at {rainbow_gems_2[i][0]} {rainbow_gems_2[i][1]}')
                        explode_gem(board2,rainbow_gems_2[i][1],rainbow_gems_2[i][0],'board 2',board_gem_2)
                    else:
                        score = 0
                        for i in range(8):
                            for j in range(8):
                                if board_gem_2[j][i] == 'â¬›':
                                    score += 100
            print(f'score 2 {score}')
            score2 = score
            asdf = ( score,rainbow_gems[1])
            scores_array.append(asdf)
            if len(rainbow_gems) > 2:
                for i in range(len(rainbow_gems_3)):
                        if original_board[rainbow_gems_3[i][1]][rainbow_gems_3[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 3  after rainbow move at {rainbow_gems_3[i][0]} {rainbow_gems_3[i][1]}')
                            explode_gem(board2,rainbow_gems_3[i][1],rainbow_gems_3[i][0],'board 3',board_gem_3)
                        else:
                            score = 0
                            for i in range(8):
                                for j in range(8):
                                    if board_gem_3[j][i] =='â¬›':
                                        score+=100
                print(f'score 3 {score}')
                asdf = ( score,rainbow_gems[2])
                scores_array.append(asdf)
            score3 = score

            if len(rainbow_gems) > 3:
                score = 0
                for i in range(len(rainbow_gems_4)):
                        if original_board[rainbow_gems_4[i][1]][rainbow_gems_4[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 4 after rainbow move at {rainbow_gems_4[i][0]} {rainbow_gems_4[i][1]}')
                            explode_gem(board2,rainbow_gems_4[i][1],rainbow_gems_4[i][0],'board 4',board_gem_4)
                        else:

                            for i in range(8):
                                for j in range(8):
                                    if board_gem_4[j][i] =='â¬›':
                                        score+=100
                print(f'score 4 {score}')
                asdf = ( score,rainbow_gems[3])
                scores_array.append(asdf)
            score4 = score
            print(f'scores array {scores_array}  rianbow gems {rainbow_gems}')
            print('-----------------------')
            if len(rainbow_gems) > 3:
                score_array = [(score1,1),(score2,2),(score3,3),(score4,4)]
                array_boards = [board_gem_1, board_gem_2, board_gem_3, board_gem_4]
            elif len(rainbow_gems) > 2:
                score_array = [(score1, 1), (score2, 2), (score3, 3)]
                array_boards = [board_gem_1, board_gem_2, board_gem_3]
            else:
                score_array = [(score1, 1), (score2, 2)]
                array_boards = [board_gem_1, board_gem_2]
            sorted_score_array = sorted(score_array)
            print(sorted_score_array[-1])


            board_to_print = array_boards[sorted_score_array[-1][1]-1]
            print(f'the best gem to use in rainbow is {rainbow_gems[sorted_score_array[-1][1]-1]}')
            ##################### CALL A FUNCTION THAT WILL MAKE THAT MOVE #####################################
            for row in board_to_print:
                print(' '.join(row))
    print(no_rainbow)
    #boardformoves


    if True:
            moves_arr = []
            for moves in all_moves:
                boardformoves = copy.deepcopy(original_board)
                if moves[2] == 'left':

                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1]][moves[0]-1] = boardformoves[moves[1]][moves[0]-1],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    ##recursive function and shit like that
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves,converted_board)
                    print('board for moves after functions')
                    score = check_for_rows(original_board,converted_board)
                    print(score)
                    asdf = (score, moves)
                    moves_arr.append(asdf)

                elif moves[2] == 'right':
                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1]][moves[0]+1] = boardformoves[moves[1]][moves[0]+1],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    score = check_for_rows(original_board, converted_board)
                    print(score)
                    asdf = (score, moves)
                    moves_arr.append(asdf)
                elif moves[2] == 'down':
                    boardformoves[moves[1]][moves[0]],boardformoves[moves[1]+1][moves[0]] = boardformoves[moves[1]+1][moves[0]],boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print()
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    score = check_for_rows(original_board, converted_board)
                    print(score)
                    asdf = (score, moves)
                    moves_arr.append(asdf)

                elif moves[2] == 'up':
                    boardformoves[moves[1]][moves[0]], boardformoves[moves[1] - 1][moves[0]] = boardformoves[moves[1] - 1][moves[0]], boardformoves[moves[1]][moves[0]]
                    print('board for moves before functions')
                    for row in boardformoves:
                        print(' '.join(row))
                    print('---------')
                    board_convert = copy.deepcopy(boardformoves)
                    converted_board = convert_board(board_convert)
                    check_for_rows(boardformoves, converted_board)
                    print('board for moves after functions')
                    score = check_for_rows(original_board, converted_board)
                    print(score)
                    asdf = (score, moves)
                    moves_arr.append(asdf)

            print(moves_arr)

            print(scores_array)
            #print(max_val)
            for a in scores_array:
                print(a)
                moves_arr.append(a)
            moves_arr = sorted(moves_arr, key=lambda x: x[0], reverse=True)
            print(moves_arr)

            #print(f'move will be made from x: {moves_arr[0][1][0]} y: {moves_arr[0][1][1]} to side: {moves_arr[0][1][2]}')
            if isinstance(moves_arr[0][1], tuple):
                print(f'move will be made from x: {moves_arr[0][1][0]} y: {moves_arr[0][1][1]} to side: {moves_arr[0][1][2]}')
                make_move(moves_arr[0][1][0],moves_arr[0][1][1],moves_arr[0][1][2])
            else:
                print(moves_arr[0][1])
                gems_and_moves = []
                #print(type(moves_arr[0][1]))
                for i in range(8):
                    for j in range(8):
                        if original_board[j][i] == 'ğŸŒˆ':
                            move1 = (original_board[j][i-1],'left')
                            #if move1[1] not in gems_and_moves:
                            gems_and_moves.append(move1)
                            move1 = (original_board[j][i + 1], 'right')
                            gems_and_moves.append(move1)
                            move1 = (original_board[j+1][i], 'down')
                            gems_and_moves.append(move1)
                            move1 = (original_board[j-1][i ], 'up')
                            gems_and_moves.append(move1)
                            pos_on_board = (j,i)
                print(gems_and_moves)
                for move in gems_and_moves:
                    if moves_arr[0][1] == move[0]:
                        print(f' gem {move[1]} pos x:{pos_on_board[1]} pos y:{pos_on_board[0]}')
                        #move function
                        make_move(pos_on_board[1],pos_on_board[0],move[1])
                        break

    #print(scores_array)



def przesun_czarne_do_gory(tablica):
        wysokosc = len(tablica)
        szerokosc = len(tablica[0])

        for kolumna in range(szerokosc):
            kolumna_tablicy = [tablica[wiersz][kolumna] for wiersz in range(wysokosc)]
            kolumna_bez_czarnych = [blok for blok in kolumna_tablicy if blok != "â¬›"]
            kolumna_tablicy = ["â¬›"] * (wysokosc - len(kolumna_bez_czarnych)) + kolumna_bez_czarnych

            for wiersz in range(wysokosc):
                tablica[wiersz][kolumna] = kolumna_tablicy[wiersz]

        return tablica


def group_positions(positions):
    groups = []

    for pos in positions:
        added_to_group = False
        for group in groups:
            for group_pos in group:
                if abs(pos[0] - group_pos[0]) <= 1 and abs(pos[1] - group_pos[1]) <= 1:
                    group.append(pos)
                    added_to_group = True
                    # print(f'{groups}')
                    break
            if added_to_group:
                # print(f'{groups}')
                break

        if not added_to_group:
            groups.append([pos])
    print(f' groups: {groups}')
    return groups


def explode_gem(board,y,x,strin,board_to_overwrite):
    print(f'board state:')
    score= 0
    gem_exploded = 0
    for row in board:
        print(' '.join(row))
    if board[y][x] == 'â¬›': return
    board2 = copy.deepcopy(board)
    print(f'{strin}, x:{x}, y:{y} ')
    print('board to voerwrite')
    for row in board_to_overwrite:
        print(' '.join(row))

    print('---------------------')
    pos_of_powered = []
    powered_gems_array = ['ğŸŸ£', 'âšª', 'ğŸŸ ', 'ğŸ”´', 'ğŸŸ¢', 'ğŸ”µ', 'ğŸŸ¡']

    for i in range(8):
        for j in range(8):
            if original_board[j][i] in powered_gems_array:
                pos = (i,j)
                pos_of_powered.append(pos)

    print(f'powered gem pos {pos_of_powered}')


    gem_groups =group_positions(pos_of_powered)
    gem = (x,y)
    group_of_gems = [] #chain
    #print(f'orig board 2{original_board}')
    for group in gem_groups:
        if gem in group:
            print(f'gem found in group {group}')
            group_of_gems = group
    print(f' remaining pos {pos}')
    for pos in group_of_gems:
        for i in range(pos[0] - 1, pos[0] + 2):
            for j in range(pos[1] - 1, pos[1] + 2):
                if i > -1 and i < 8 and j > -1 and j < 8:
                    board2[j][i] = 'â¬›'
        score+=300
        gem_exploded +=1

    print('test score')

    print('state of board after explode')
    for row in board2:
        print(' '.join(row))

    print('state of board after explode with other black places')

    for i in range(8):
        for j in range(8):
            if board2[j][i] == 'â¬›' or board2[j][i] == 'ğŸŒˆ':
                board_to_overwrite[j][i] = 'â¬›'
    for row in board_to_overwrite:
        print(' '.join(row))
    #explode_gem(board2, 4, 6, 'sdfg')
    board2 = original_board
    # WywoÅ‚anie funkcji i wydrukowanie wyniku
    print('------------------------')
    wynik = przesun_czarne_do_gory(board_to_overwrite)
    for wiersz in wynik:
        print(" ".join(wiersz))
    for i in range(8):
        for j in range(8):
            if board_to_overwrite[j][i] == 'â¬›':
                score += 100

    print(score - gem_exploded*100)







final_board =\
[['ğŸŸ§', 'ğŸŸ¨', 'ğŸŸ¦', 'ğŸŸ§', 'ğŸŸ¨', 'â¬œ', 'ğŸŸ¦', 'ğŸŸª'],
['ğŸŸ©', 'â¬œ', 'â¬œ', 'ğŸŸª', 'ğŸŸ©', 'ğŸŸ¨', 'â¬œ', 'ğŸŸ©'],
['ğŸŸ¨', 'ğŸŸ§', 'ğŸŸ¥', 'ğŸŸ¦', 'â¬œ', 'ğŸŸ©', 'â¬œ', 'â¬œ'],
['ğŸŸ¦', 'ğŸŸ¥', 'ğŸŸª', 'ğŸŸª', 'â¬œ', 'ğŸŸª', 'ğŸŸ§', 'ğŸŸ¥'],
['ğŸŸ§', 'ğŸŒˆ', 'â¬œ', 'âšª', 'ğŸŸ¦', 'ğŸŸ§', 'ğŸ”µ', 'ğŸŸ¦'],
['ğŸŸ¥', 'ğŸŸª', 'â¬œ', 'ğŸŸ ', 'ğŸŸª', 'ğŸŸ¥', 'ğŸŸ§', 'ğŸŸ¥'],
['ğŸŸ¥', 'ğŸŸ¥', 'ğŸŸ¨', 'ğŸ”µ', 'ğŸŸ¨', 'ğŸŸ¥', 'ğŸŸª', 'ğŸŸª'],
['ğŸŸ§', 'ğŸŸ¨', 'ğŸŸª', 'ğŸŸ¥', 'â¬œ', 'ğŸŸ©', 'ğŸŸ¦', 'ğŸŸª']]
#check_for_moves(final_board)
while True:
    time.sleep(1)
    test()
#explode_gem(final_board, 6, 3, 'sdfg')
