import pyautogui
import time
from PIL import ImageGrab
import numpy as np
import matplotlib.pyplot as plt
from PIL import ImageGrab, Image, ImageEnhance
import cv2
import numpy as np
from matplotlib import pyplot as plt




wylosowane_kolory = [(199, 22, 199), (255, 255, 130), (246, 246, 246), (255,165,0), (49, 171, 253), (19, 202, 19),
                     (255, 99, 99),(0,0,0)]  # in order: pink, yellow,white, orange, blue, green,red
kolory = ['pink','yellow','white','orange','blue','green','red','black']
timer = 0
a = input('input   S   to start')
if a == '':

    x, y = pyautogui.position()
    width, height = 53 * 8, 53 * 8

    screenshot = ImageGrab.grab(bbox=(x, y, x + width, y + height))

    # Konwertuj zrzut ekranu na tablicÄ™ numpy
    screenshot_np = np.array(screenshot)

    # Oblicz dominujÄ…cy kolor w kaÅ¼dym kwadracie
    for i in range(8):
        for j in range(8):
            # OkreÅ›l wspÃ³Å‚rzÄ™dne aktualnego kwadratu
            square_x, square_y = j * 53, i * 53
            square = screenshot_np[square_y:square_y + 53, square_x:square_x + 53]

            # Oblicz Å›redni kolor w kwadracie
            avg_color = np.mean(square, axis=(0, 1))

            # WyÅ›wietl Å›redni kolor (moÅ¼esz dalej przypisaÄ‡ go do rodzaju krysztaÅ‚u)
            print(f"Kwadrat ({i}, {j}): DominujÄ…cy kolor = {avg_color}")

    plt.imshow(screenshot)
    plt.axis('on')  # WyÅ‚Ä…cz osie
    plt.show()

    # Uwaga: MoÅ¼esz przypisaÄ‡ Å›redni kolor do rodzaju krysztaÅ‚u na podstawie swojego mapowania kolorÃ³w
    # i dodaÄ‡ logikÄ™ rozpoznawania tÄ™czowych i ulepszonych krysztaÅ‚Ã³w.
    # Dostosuj wspÃ³Å‚rzÄ™dne i inne parametry wedÅ‚ug potrzeb.



    array_color = []
    for i in range(3):
        time.sleep(0.01)
        x, y = pyautogui.position()
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

        print(aktualny_kolor)
        print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):
            for i in range(8):
                new_x = x + 53 * i
                new_y = y + 53 * j
                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›'
        }
        color = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color[i][j] = color_mapping[colors[index]]
        for row in color:
            print(' '.join(row))
        print(color)
    print(array_color)


    # Wykonaj zrzut ekranu
    width, height = 53 * 8, 53 * 8
    xx, yy = pyautogui.position()
    # Wykonaj zrzut ekranu w okreÅ›lonym obszarze
    screenshot = pyautogui.screenshot(region=(xx, yy, width, height))
    screenshot.save("screenshot.png")

    # ZaÅ‚aduj zrzut ekranu
    edited_screenshot = Image.open("screenshot.png")

    # Edytuj zrzut ekranu (zmniejsz nasycenie, zwiÄ™ksz jasnoÅ›Ä‡ itp.)
    enhancer = ImageEnhance.Color(edited_screenshot)
    edited_screenshot = enhancer.enhance(0)  # Zmniejsz nasycenie
    edited_screenshot = edited_screenshot.point(lambda p: p * 7)  # ZwiÄ™ksz jasnoÅ›Ä‡

    # Zapisz zedytowany zrzut ekranu
    edited_screenshot.save("edited_screenshot.png")

    # ZaÅ‚aduj zedytowany zrzut ekranu za pomocÄ… OpenCV
    edited_screenshot_cv = cv2.imread("edited_screenshot.png")



    # WyÅ›wietl zedytowany zrzut ekranu
    cv2.imshow("Edited Screenshot", edited_screenshot_cv)
    cv2.waitKey(0)

    cv2.destroyAllWindows()


    # reading image
    img = cv2.imread("TEST.png")

    # converting image into grayscale image
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # setting threshold of gray image
    _, threshold = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

    # using a findContours() function
    contours, _ = cv2.findContours(
        threshold, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    i = 0

    # list for storing names of shapes
    for contour in contours:

        # here we are ignoring first counter because
        # findcontour function detects whole image as shape
        if i == 0:
            i = 1
            continue

        # cv2.approxPloyDP() function to approximate the shape
        approx = cv2.approxPolyDP(
            contour, 0.01 * cv2.arcLength(contour, True), True)

        # using drawContours() function
        cv2.drawContours(img, [contour], 0, (0, 0, 255), 5)

        # finding center point of shape
        M = cv2.moments(contour)
        if M['m00'] != 0.0:
            x = int(M['m10'] / M['m00'])
            y = int(M['m01'] / M['m00'])

        # putting shape name at center of each shape
        if len(approx) == 3:
            cv2.putText(img, '4', (x, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        elif len(approx) == 4:
            cv2.putText(img, '4', (x, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        elif len(approx) == 6:
            cv2.putText(img, '6', (x, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        elif len(approx) == 8:
            cv2.putText(img, '8', (x, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

        else:
            cv2.putText(img, '10', (x, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

            # displaying the image after drawing contours
    cv2.imshow('shapes', img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()
