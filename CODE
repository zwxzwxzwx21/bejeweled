import pyautogui
import time
import numpy as np
import matplotlib.pyplot as plt
from PIL import ImageGrab, Image, ImageEnhance
import cv2
from matplotlib import pyplot as plt
import subprocess
import copy
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
debug = False
start_time =time.time()
#opening the game
subprocess.Popen(["D:\\Bejeweled 2 Deluxe\\Bejeweled2.exe"])

#windows title moving to the corner
win = pyautogui.getWindowsWithTitle('Bejeweled 2 Deluxe 1.0')[0]

win.activate()
win.moveTo(0, 0)



#(82, 76, 24),
wylosowane_kolory = [(199, 22, 199), (220, 220, 50), (230, 220, 220), (255,135,0), (49, 171, 253), (19, 202, 19), (255, 99, 99),(0,0,0),(82, 76, 24),(255,255,255)]
            # in order: pink,               yellow,         white,          orange,      blue,         green,           red
kolory = ['pink','yellow','white','orange','blue','green','red','black','brown','rainbow']


timer = 0
#coordinated for drawing dots on image
kordy = []
a = ''
import cProfile
def test():

    x, y = pyautogui.position()
    width, height = 85 * 8, 84 * 8

    screenshot = ImageGrab.grab(bbox=(305, 62, 305 + width, 62 + height))


    plt.imshow(screenshot)
    plt.axis('on')  # WyÅ‚Ä…cz osie
    plt.show()




    array_color = []
    for i in range(3):

        x, y = 305, 62
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

        #print(aktualny_kolor)
        #print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):
            for i in range(8):
                new_x = x + 85 * i + 41
                new_y = y + 84 * j + 42

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                #print(aktualny_kolor)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

                #print(najblizszy_kolor)
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        #print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›',
            'brown': '?',
            'rainbow': 'R'
        }
        color = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color[i][j] = color_mapping[colors[index]]
        #for row in color:
            #print(' '.join(row))
        #print(color)
    #print(array_color)
    for i in range(3):

        x, y = 305, 62
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
        #variable to make dots even or something
        t,t2 = 0 , -1
        #print(aktualny_kolor)
        #print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):

            for i in range(8):
                t+=1
                if t == 2:
                    t2+=1
                new_x = x + 85 * i + 6 - i + t2 + 2
                new_y = y + 84 * j + 42
                kordy.append((new_x-305,new_y-62))

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                #print(aktualny_kolor)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
                #print(najblizszy_kolor)
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        #print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›',
            'brown': 'P',
            'rainbow': 'R'
        }
        color_power = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color_power[i][j] = color_mapping[colors[index]]
        for row in color_power:
            print(' '.join(row))
        #print(f' [color_power]= {color_power}')
    #print(array_color)
    #print(len(kordy))
    #print(kordy)


    # compare arrays to determine what is what
    first_color_array = []
    second_color_array = []
    for gem in color:
        first_color_array+=gem
    #print(first_color_array)
    for gem in color_power:
        second_color_array+=gem


    #comparing
    #new array to have new board state
    pre_final_board = []
    for i in range(64):
        if second_color_array[i] == 'P' and first_color_array[i] == 'R':
            pre_final_board.append('âšª')
        elif second_color_array[i] == 'â¬›' and first_color_array[i] == 'R':
            pre_final_board.append('ðŸŒˆ')
        elif first_color_array[i] == 'ðŸŸ¨' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¨')
        elif first_color_array[i] == 'ðŸŸ¥' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¥')
        elif first_color_array[i] == 'ðŸŸ§' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ§')
        elif first_color_array[i] == 'ðŸŸ¦' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¦')
        elif first_color_array[i] == 'ðŸŸ©' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ©')
        elif first_color_array[i] == 'ðŸŸª' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸª')
        elif first_color_array[i] == 'â¬œ' and second_color_array[i] != 'P':
            pre_final_board.append('â¬œ')
        elif first_color_array[i] == 'ðŸŸ¨' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ¡')
        elif first_color_array[i] == 'ðŸŸ¥' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸ”´')
        elif first_color_array[i] == 'ðŸŸ§' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ ')
        elif first_color_array[i] == 'ðŸŸ¦' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸ”µ')
        elif first_color_array[i] == 'ðŸŸ©' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ¢')
        elif first_color_array[i] == 'ðŸŸª' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ£')
    # ðŸ”´ðŸŸ ðŸŸ¡ðŸŸ¢ðŸ”µðŸŸ£
    print(f'pre array{pre_final_board}')
    final_board = [['' for _ in range(8)] for _ in range(8)]
    color_mapping = {
        'ðŸŸ¨': 'ðŸŸ¨',
        'ðŸŸ¦': 'ðŸŸ¦',
        'ðŸŸª': 'ðŸŸª',
        'â¬œ': 'â¬œ',
        'ðŸŸ©': 'ðŸŸ©',
        'ðŸŸ§': 'ðŸŸ§',
        'ðŸŸ¥': 'ðŸŸ¥',
        'ðŸ”µ': 'ðŸ”µ',
        'âšª': 'âšª',
        'ðŸŒˆ': 'ðŸŒˆ',
        'ðŸ”´': 'ðŸ”´',
        'ðŸŸ£': 'ðŸŸ£',
        'ðŸŸ¢': 'ðŸŸ¢',
        'ðŸŸ ': 'ðŸŸ ',
        'ðŸŸ¡': 'ðŸŸ¡',
    }

    for i, emoji in enumerate(pre_final_board):
        row = i // 8
        col = i % 8
        final_board[row][col] = color_mapping.get(emoji, 'unknown')

    # WyÅ›wietlenie ramki final_board
    for row in final_board:
        print(row)
    end_time = time.time()
    print(f' elapsed in seconds:{end_time - start_time}')
    global original_board
    original_board =copy.deepcopy(final_board)
    print(f' orig {original_board}') # dobry
    #convert the board to cound powered gems as normal gems so you can make moves with normal and powered
    converted_board = [['' for _ in range(8)] for _ in range(8)]
    emoji_mapping = {
        'ðŸŸ¨': 'ðŸŸ¨',  # yellow
        'ðŸŸ¦': 'ðŸŸ¦',  # blue
        'ðŸŸ©': 'ðŸŸ©',  # green
        'ðŸŸª': 'ðŸŸª',  # purple
        'â¬œ': 'â¬œ',  # white
        'ðŸŸ¥': 'ðŸŸ¥',  # red
        'ðŸŒˆ': 'ðŸŒˆ',  # rainbow
        'âšª': 'â¬œ',  # white circle
        'ðŸ”µ': 'ðŸŸ¦',  # blue circle -> blue square
        'ðŸ”´': 'ðŸŸ¥',  # red circle -> red square
        'ðŸŸ£': 'ðŸŸª',  # purple circle -> purple square
        'ðŸŸ¢': 'ðŸŸ©',  # green circle -> green square
        'ðŸŸ ': 'ðŸŸ§',  # orange
        'ðŸŸ¡': 'ðŸŸ¨'  # yellow circle -> yellow square
    }
    for i in range(8):
        for j in range(8):
            gem = final_board[i][j]
            if gem in emoji_mapping:
                converted_board[i][j] = emoji_mapping[gem]
            else:
                converted_board[i][j] = gem
    for row in converted_board:
        print(' '.join(row))
    check_for_moves(converted_board)


def check_for_moves(final_board):
    horizontal_pair_of_gems = []
    vertical_pair_of_gems = []
    available_vertical_moves = 0

    #moves based off of position of the gem that will create a move, ie. the one that dissapeares after move
    #gem positions will be stored here and off of those arrays moves will be calculated
    moves_to_left = []
    moves_to_right = []
    moves_to_down = []
    moves_to_up = []

    for i in range(8):
        for j in range(7):
            if final_board[i][j] == final_board[i][j + 1]:
                horizontal_pair_of_gems.append(((j,i),(j+1,i)))
    for j in range(8):
        for i in range(7):
            if final_board[i][j] == final_board[i+1][j]:
                vertical_pair_of_gems.append(((j,i),(j,i+1)))
    print('vertical pairs:')
    print(vertical_pair_of_gems)
    print('horizontal pairs:')
    print(horizontal_pair_of_gems)

    print('vertical moves with pair')
    for i in range(len(vertical_pair_of_gems)):
        #try:
            if debug:print(vertical_pair_of_gems[i])
            if debug:print(final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])])

            if (vertical_pair_of_gems[i][0][0])-1 < 0 or (vertical_pair_of_gems[i][0][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the left')



            else:
                if debug:
                    print(f'gem higher 1 and left:{final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0]) - 1, vertical_pair_of_gems[i][0][1] - 1,'316')
                    if move not in moves_to_right:
                        moves_to_right.append(move)


                    available_vertical_moves += 1




            if debug: print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][0][0])-1} {(vertical_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][0][0]) + 1 >7 or (vertical_pair_of_gems[i][0][1])-1  < 0 or (vertical_pair_of_gems[i][0][1]) > 8: # might have errors
                if debug:
                    print('incorrect position for gem 1 higher and 1 to the right')
                    #  print((vertical_pair_of_gems[i][0][0]) + 1,(vertical_pair_of_gems[i][0][1])-1)




            else:
                if debug:
                    print(f' gem higher 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0])+1,(vertical_pair_of_gems[i][0][1])-1,'348')
                    if move not in moves_to_left:

                        moves_to_left.append(move)
                    available_vertical_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the right{(vertical_pair_of_gems[i][0][0]) + 1} {(vertical_pair_of_gems[i][0][1]-1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1])-2 < 0:
                if debug:
                    print('incorrect position for gem 2 higher')




            else:

                if debug:print(f' gem higher by 2:{final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]}') # nad parÄ…



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]:

                    available_vertical_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 HIGHER{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][0][0]),(vertical_pair_of_gems[i][0][1])-2,'378')
                    if move not in moves_to_down:

                        moves_to_down.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 higher {(vertical_pair_of_gems[i][0][0])} {(vertical_pair_of_gems[i][0][1]) - 2}{bcolors.ENDC}')

            if debug:print('------------')


    for i in range(len(vertical_pair_of_gems)):
        #try:
            print(vertical_pair_of_gems[i])
            if debug:print(final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])])

            if (vertical_pair_of_gems[i][1][0])-1 < 0 or (vertical_pair_of_gems[i][1][1])+1 > 7:

                if debug:print('incorrect position for gem 1 lower and 1 to the left')



            else:

                if debug:print(f'gem lower 1 and left:{final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 LEFT{bcolors.ENDC}')

                    move = ((vertical_pair_of_gems[i][1][0])-1,(vertical_pair_of_gems[i][1][1])+1,'411')
                    if move not in moves_to_right:
                        moves_to_right.append(move)
                    available_vertical_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][1][0])-1} {(vertical_pair_of_gems[i][1][1])+1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][1][0]) + 1 >7 or (vertical_pair_of_gems[i][1][1])+1  > 7 or (vertical_pair_of_gems[i][1][1]) > 8: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the right')
                #print((vertical_pair_of_gems[i][1][0]) + 1,(vertical_pair_of_gems[i][1][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 RIGHT{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][1][0])+1,(vertical_pair_of_gems[i][1][1])+1,'441')
                    if move not in moves_to_left:

                        moves_to_left.append(move)

                    available_vertical_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the righT {(vertical_pair_of_gems[i][1][0]) + 1} {(vertical_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (vertical_pair_of_gems[i][1][0]) < 0 or (vertical_pair_of_gems[i][1][1])+2 > 7:

                if debug:print('incorrect position for gem 2 lower')




            else:

                if debug:print(f' gem lower by 2:{final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][1][0])]}') # pod parÄ…



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])]:

                    available_vertical_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 lower{bcolors.ENDC}')
                    move = ((vertical_pair_of_gems[i][1][0]),(vertical_pair_of_gems[i][1][1])+2,'472')
                    if move not in moves_to_up:

                        moves_to_up.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 lower {(vertical_pair_of_gems[i][1][0])} {(vertical_pair_of_gems[i][1][1]) + 2}{bcolors.ENDC}')

            if debug:print('------------')


    #print(f'{bcolors.FAIL} VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')
    print(f'{bcolors.OKBLUE}VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')

    #HORIZONTAL EASY MOVES
    print('horizontal moves with pair')
    available_horizontal_moves = 0
    print(f'################ HORIZONTAL MOVES #####################')
    for i in range(len(horizontal_pair_of_gems)):
        #try:
            print(horizontal_pair_of_gems[i])
            if debug:print(final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])])

            if (horizontal_pair_of_gems[i][0][0])-1 < 0 or (horizontal_pair_of_gems[i][0][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the left')



            else:

                if debug:print(f'gem higher 1 and left:{final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])-1,'511')
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen 1 higher on the left {(horizontal_pair_of_gems[i][0][0])-1} {(horizontal_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][0][0]) - 1 <0 or (horizontal_pair_of_gems[i][0][1])+1  > 7 or (horizontal_pair_of_gems[i][0][1]) > 8: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the left')
                if debug:print((horizontal_pair_of_gems[i][0][0]) - 1,(horizontal_pair_of_gems[i][0][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the left: {final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-1,(horizontal_pair_of_gems[i][0][1])+1,'542')
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the left{(horizontal_pair_of_gems[i][0][0]) - 1} {(horizontal_pair_of_gems[i][0][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (horizontal_pair_of_gems[i][0][0])-2 < 0 or (horizontal_pair_of_gems[i][0][1]) < 0:

                if debug:print('incorrect position for gem 2 to left')




            else:

                if debug:print(f' gem left  by 2:{final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2] == final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]:

                    available_horizontal_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO LEFT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][0][0])-2,(horizontal_pair_of_gems[i][0][1]),'572')
                    if move not in moves_to_right:

                        moves_to_right.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 to left {(horizontal_pair_of_gems[i][0][0])-2} {(horizontal_pair_of_gems[i][0][1])}{bcolors.ENDC}')

            if debug:print('------------')


    for i in range(len(horizontal_pair_of_gems)):
        #try:
            print(horizontal_pair_of_gems[i])
            if debug:print(final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])])

            if (horizontal_pair_of_gems[i][1][0])+1 > 7 or (horizontal_pair_of_gems[i][1][1])-1  < 0:

                if debug:print('incorrect position for gem 1 higher and 1 to the right')



            else:

                if debug:print(f'gem higher 1 and right:{final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])-1,'604')
                    if move not in moves_to_down:

                        moves_to_down.append(move)
                    available_horizontal_moves += 1




            if debug:print(f'{bcolors.WARNING}position of gen 1 higher on the right {(horizontal_pair_of_gems[i][1][0])+1} {(horizontal_pair_of_gems[i][1][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][1][0]) + 1 > 7 or (horizontal_pair_of_gems[i][1][1])+1  > 7: # might have errors

                if debug:print('incorrect position for gem 1 lower and 1 to the right')
                if debug:print((horizontal_pair_of_gems[i][1][0]) + 1,(horizontal_pair_of_gems[i][1][1])+1)




            else:

                if debug:print(f' gem lower 1 and 1 to the right: {final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+1,(horizontal_pair_of_gems[i][1][1])+1,'635')
                    if move not in moves_to_up:

                        moves_to_up.append(move)
                    available_horizontal_moves += 1



            if debug:print(f'{bcolors.WARNING} position of gem in the right{(horizontal_pair_of_gems[i][1][0]) + 1} {(horizontal_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (horizontal_pair_of_gems[i][1][0])+2 > 7 or (horizontal_pair_of_gems[i][1][1]) < 0:

                if debug:print('incorrect position for gem 2 to right')




            else:

                if debug:print(f' gem right  by 2:{final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2] == final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]:

                    available_horizontal_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO RIGHT{bcolors.ENDC}')
                    move = ((horizontal_pair_of_gems[i][1][0])+2,(horizontal_pair_of_gems[i][1][1]),'665')
                    if move not in moves_to_left:

                        moves_to_left.append(move)



            if debug:print(f'{bcolors.WARNING}position of game 2 to right {(horizontal_pair_of_gems[i][1][0])+2} {(horizontal_pair_of_gems[i][1][1])}{bcolors.ENDC}')

            if debug:print('------------')


    print(f'{bcolors.OKBLUE}HORIZONTAL MOVES: {available_horizontal_moves}{bcolors.ENDC}')
    print('horizontal moves with empty middle')

    #checking for moves that would be 2 in same row and 1 higher/lower/left/right but in the middle in general
    for i in range(8):
        for j in range(8):
            try:
                if j + 2 < 8:
                    pass#print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j+2}, y2: {i}')
                else:pass
                    #print(f'incorrect position found at x: {j}')
                if final_board[i][j] == final_board[i][j+2]:
                    if i+1 < 8 and j+1 < 8:
                        if final_board[i][j] == final_board[i+1][j+1] :
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'693')
                            if move not in moves_to_up:

                                moves_to_up.append(move)


                    if i-1 > -1 and j+1 < 8:
                        if final_board[i][j] == final_board[i-1][j+1]:
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i][j + 2]} x2: {j + 2}, y2: {i}')
                            print(f'move found with gem at x: {j+1} y: {i-1}')
                            move = (j+1,i-1,'703')
                            if move not in moves_to_down:

                                moves_to_down.append(move)

            except:pass
    #same but vertical
    print('vertical  moves with empty middle')

    for i in range(8):
        for j in range(8):
            try:
                if i + 2 < 8:
                    pass
                    #print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i+2][j]} x2: {j}, y2: {i+2}')
                else:pass
                    #print(f'incorrect position found at x: {j}')
                if final_board[i][j] == final_board[i+2][j]:
                    if i+1 < 8 and j+1 < 8:
                        if final_board[i][j] == final_board[i+1][j+1] :
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            print(f'move found with gem at x: {j+1} y: {i+1}')
                            move = (j+1,i+1,'726')
                            if move not in moves_to_left:
                                moves_to_left.append(move)
                    if i+1 < 8 and j-1 > -1:
                        if final_board[i][j] == final_board[i+1][j-1]:
                            print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')

                            print(f'move found with gem at x: {j-1} y: {i+1}')
                            move = ( j - 1,i + 1,'734')
                            if move not in moves_to_right:

                                moves_to_right.append(move)

            except:pass

    print('############ MOVES BY 4 ###############')
    #moves by 4!!! horizontal
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if final_board[i][j] == final_board[i][j + 2]: # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1]:
                                if j+3 < 8:
                                    if final_board[i][j] == final_board[i][j+3]:
                                        move = (j+1,i+1,'754')
                                        if move not in moves_to_up:

                                            moves_to_up.append(move)

                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j+2} {i} fourth gem at x: {j+3} {i}')
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1]:
                                if j+3 < 8:
                                    if final_board[i][j] == final_board[i][j+3]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j + 2} {i} fourth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'765')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1]:
                                if j-1 > -1:
                                    if final_board[i][j] == final_board[i][j - 1]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i - 1} third {j+2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i - 1,'773')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)
                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1]:
                                if j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j - 1]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j + 2} {i} fourth gem at x: {j-1} {i}')
                                        move = ( j + 1,i + 1,'781')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)

    #vertical;
    print("@@@@@@@@@@@@@@@ 4 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

           if i + 2 < 8:
                if final_board[i][j] == final_board[i+2][j]:

                        if i+1 < 8 and j+1 < 8:
                            if final_board[i][j] == final_board[i+1][j+1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i+3][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j + 1,i + 1 ,'798')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)
                        if i+1 < 8 and j-1 > -1:
                            if final_board[i][j] == final_board[i+1][j-1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i+3][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j-1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i+3}')
                                        move = (j - 1,i + 1 ,'806')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                        if j-1 > -1 and i+1 < 8 and i -1 > -1 :
                            if final_board[i][j] == final_board[i+1][j-1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i - 1][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j - 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j - 1,i + 1,'814')
                                        if move not in moves_to_right:
                                            moves_to_right.append(move)
                        if i+1 < 8 and j+1 < 8 and i -1 > -1 :
                            if final_board[i][j] == final_board[i+1][j+1] :
                                if i + 3 < 8:
                                    if final_board[i][j] == final_board[i-1][j]:
                                        print(f' four move found with gem at x: {j} y: {i}, second gem at {j + 1} {i + 1} third {j} {i+2} fourth gem at x: {j} {i-1}')
                                        move = ( j + 1,i + 1,'822')
                                        if move not in moves_to_left:
                                            moves_to_left.append(move)

                        '''if i+1 < 8 and j-1 > -1:
                            if final_board[i][j] == final_board[i+1][j-1]:
                                print(f'{final_board[i][j]} x: {j}, y: {i}, {final_board[i + 2][j]} x2: {j}, y2: {i + 2}')
    
                                print(f'move found with gem at x: {j-1} y: {i+1}')'''





    print('$$$$$$$$$$$$$$ MOVES BY 5 $$$$$$$$$$$$$$$$$')
    for i in range(8):
        for j in range(8):


            if j + 2 < 8:
                if final_board[i][j] == final_board[i][j + 2]: # sprawdzianie czy gem o 2 jest taki sam

                        if i + 1 < 8 and j + 1 < 8:
                            if final_board[i][j] == final_board[i + 1][j + 1]:
                                if j+3 < 8 and j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j+3] and final_board[i][j] == final_board[i][j-1] :
                                        print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j-1} {i}  third gem at {j} {i} fourth {j+2} {i} fifth gem at x: {j+3} {i}')
                                        move = (j + 1,i + 1,'849')
                                        if move not in moves_to_up:
                                            moves_to_up.append(move)
                        if i - 1 > -1 and j + 1 < 8:
                            if final_board[i][j] == final_board[i - 1][j + 1]:
                                if j+3 < 8 and j - 1 > -1:
                                    if final_board[i][j] == final_board[i][j+3] and final_board[i][j] == final_board[i][j-1]:
                                        print(f' five move found with gem at x: {j+1} y: {i-1}, second gem at {j-1} {i} third gem at {j} {i} fourth {j + 2} {i} fifth gem at x: {j + 3} {i}')
                                        move = ( j + 1,i - 1,'857')
                                        if move not in moves_to_down:
                                            moves_to_down.append(move)



    print("@@@@@@@@@@@@@@@ 5 moves vertical; @@@@@@@@@@@@@@@@@@")
    for i in range(8):
        for j in range(8):

            if i + 2 < 8:
                if final_board[i][j] == final_board[i + 2][j]:

                    if i + 1 < 8 and j + 1 < 8:
                        if final_board[i][j] == final_board[i + 1][j + 1]:
                            if i + 3 < 8 and i -1 > -1:
                                if final_board[i][j] == final_board[i + 3][j] and final_board[i][j] == final_board[i-1][j]:
                                    print(f' five move found with gem at x: {j+1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x: {j} {i+3}')
                                    move = (j + 1,i + 1 ,'875')
                                    if move not in moves_to_left:
                                        moves_to_left.append(move)
                    if i + 1 < 8 and j - 1 > -1:
                        if final_board[i][j] == final_board[i + 1][j - 1]:
                            if i + 3 < 8 and i-1 > -1:
                                if final_board[i][j] == final_board[i + 3][j] and final_board[i][j] == final_board[i-1][j]:

                                    print(f' five move found with gem at x: {j-1} y: {i+1}, second gem at {j} {i - 1} third {j} {i} fourth gem at x: {j} {i + 2} fifth gem at x {j} {i+3}')
                                    move = (j - 1,i + 1 ,'884')
                                    if move not in moves_to_right:
                                        moves_to_right.append(move)



    print(f'{bcolors.BOLD} MOVES {bcolors.ENDC}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO LEFT: {moves_to_left}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO RIGHT: {moves_to_right}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO UP: {moves_to_up}')
    print(f'{bcolors.BOLD}{bcolors.OKCYAN} TO DOWN: {moves_to_down}{bcolors.ENDC}')

    calculate_moves(original_board,final_board)




    #SCORING AND WRITING BOARD


def calculate_moves1(original_board,final_board):
    pass














def calculate_moves(original_board,final_board):

    print(f' orig {original_board}')
    rainbow_gems = [] # gems next to rainbow to remove if using rainbow is a good move
    #niszceznie gemow na oryginalnym nboardzie
    for i in range(8):
        if 'ðŸŒˆ' in original_board[i]:
            #niszczenie gemow i pobieranie ich posyzji na zmienionym boardzie gdzie powered gems jest taki sam jak zwykly gem
            for i in range(8):
                for j in range(8):
                    if original_board[i][j] == 'ðŸŒˆ':
                        if i-1>-1 and j+1 < 8 and j-1 > -1 and i+1 < 8:
                            print(f'rainbow gem found gems around: {final_board[i-1][j]} {final_board[i+1][j]} {final_board[i][j+1]} {final_board[i][j-1]}')
                        else:
                            print('rainbow next to side board, gems found around:')
                            if i - 1 > -1:
                                print(final_board[i-1][j])
                            if i + 1 < 8:
                                print(final_board[i+1][j])
                            if j + 1 < 8:
                                final_board[i][j + 1]
                            if j - 1 > -1:
                                final_board[i][j - 1]
                        if i-1 > -1:
                            if final_board[i-1][j] not in final_board:
                                rainbow_gems.append(final_board[i-1][j])
                        if i+1 < 8:
                            if final_board[i + 1][j] not in final_board:
                                rainbow_gems.append(final_board[i+1][j])
                        if j+1 < 8:
                            if final_board[i][j+1] not in final_board:
                                rainbow_gems.append(final_board[i][j+1])
                        if j-1 > -1:
                            if final_board[i][j-1] not in final_board:
                                rainbow_gems.append(final_board[i][j-1])
            rainbow_gems_1 = [] # position of gem 1 on board to remove
            rainbow_gems_2 = [] # position of gem 2 on board to remove
            rainbow_gems_3 = [] # position of gem 3 on board to remove
            rainbow_gems_4 = [] # position of gem 4 on board to remove
            loop = 0
            for gem in rainbow_gems:
                loop+=1
                board = copy.deepcopy(final_board)


                for i in range(8):
                    for j in range(8):

                        if board[i][j] == gem or board[i][j] == 'ðŸŒˆ':         # MAYBE BUGS????????????????????????????????????????????????? comment ðŸŒˆ if yes

                            board[i][j] = 'â¬›'
                            if gem == rainbow_gems[0]:
                                move = (j,i)
                                rainbow_gems_1.append(move)
                            if gem == rainbow_gems[1]:
                                move = (j,i)
                                rainbow_gems_2.append(move)
                            if len(rainbow_gems)>2:
                                if gem == rainbow_gems[2]:
                                    move = (j,i)
                                    rainbow_gems_3.append(move)
                            if len(rainbow_gems) > 3:
                                if gem == rainbow_gems[3]:
                                    move = (j,i)
                                    rainbow_gems_4.append(move)
                print(f'board after using rainbow moves for {gem}')
                for row in board:
                    print(' '.join(row))
                if loop == 1:
                    board_gem_1 = board
                    print(board_gem_1)
                elif loop == 2:
                    board_gem_2 = board
                    print(board_gem_2)
                elif loop == 3:
                    board_gem_3 = board
                    print(board_gem_3)
                elif loop == 4:
                    board_gem_4 = board
                    print(board_gem_4)

                print('-----------------------')

            print(f'board_gem_1 {rainbow_gems[0]}')
            for row in board_gem_1:
                print(' '.join(row))

            print(f'board_gem_2 {rainbow_gems[1]}')
            for row in board_gem_2:
                print(' '.join(row))

            if len(rainbow_gems) > 2:
                print(f'board_gem_3 {rainbow_gems[2]}')
                for row in board_gem_3:
                    print(' '.join(row))

            if len(rainbow_gems) > 3:
                print(f'board_gem_4 {rainbow_gems[3]}')
                for row in board_gem_4:
                    print(' '.join(row))

            print(f' lenght of array 1 (rainbow_gems_1){len(rainbow_gems_1)}')
            print(f' lenght of array 1 (rainbow_gems_2){len(rainbow_gems_2)}')
            if len(rainbow_gems) > 2:
                print(f' lenght of array 1 (rainbow_gems_3){len(rainbow_gems_3)}')
            if len(rainbow_gems) > 3:
                print(f' lenght of array 1 (rainbow_gems_4){len(rainbow_gems_4)}')
            powered_gems_array = ['ðŸŸ£', 'âšª', 'ðŸŸ ', 'ðŸ”´', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ¡']
            board2 = copy.deepcopy(original_board)
            for i in range(len(rainbow_gems_1)):

                    if original_board[rainbow_gems_1[i][1]][rainbow_gems_1[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 1 after rainbow move at {rainbow_gems_1[i][0]} {rainbow_gems_1[i][1]}')
                        explode_gem(board2,rainbow_gems_1[i][1],rainbow_gems_1[i][0], 'board 1',board_gem_1)
                    else:
                        score = 0
                        for i in range(8):
                            for j in range(8):
                                if board_gem_1[j][i] == 'â¬›':
                                    score += 100
            print(f'score 1 {score}')
            for i in range(len(rainbow_gems_2)):
                    if original_board[rainbow_gems_2[i][1]][rainbow_gems_2[i][0]] in powered_gems_array:
                        print(f'powered  gem found in array 2 after rainbow move at {rainbow_gems_2[i][0]} {rainbow_gems_2[i][1]}')
                        explode_gem(board2,rainbow_gems_2[i][1],rainbow_gems_2[i][0],'board 2',board_gem_2)
                    else:
                        score = 0
                        for i in range(8):
                            for j in range(8):
                                if board_gem_2[j][i] == 'â¬›':
                                    score += 100
            print(f'score 2 {score}')
            if len(rainbow_gems) > 2:
                for i in range(len(rainbow_gems_3)):
                        if original_board[rainbow_gems_3[i][1]][rainbow_gems_3[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 3  after rainbow move at {rainbow_gems_3[i][0]} {rainbow_gems_3[i][1]}')
                            explode_gem(board2,rainbow_gems_3[i][1],rainbow_gems_3[i][0],'board 3',board_gem_3)
                        else:
                            score = 0
                            for i in range(8):
                                for j in range(8):
                                    if board_gem_3[j][i] =='â¬›':
                                        score+=100
            print(f'score 3 {score}')
            if len(rainbow_gems) > 3:
                for i in range(len(rainbow_gems_4)):
                        if original_board[rainbow_gems_4[i][1]][rainbow_gems_4[i][0]] in powered_gems_array:
                            print(f'powered  gem found in array 4 after rainbow move at {rainbow_gems_4[i][0]} {rainbow_gems_4[i][1]}')
                            explode_gem(board2,rainbow_gems_4[i][1],rainbow_gems_4[i][0],'board 4',board_gem_4)
                        else:
                            score = 0
                            for i in range(8):
                                for j in range(8):
                                    if board_gem_4[j][i] =='â¬›':
                                        score+=100
            print(f'score 4 {score}')

            print('-----------------------')

        #print(original_board)

        #print(final_board)
        '''for i in range(8):
            for j in range(8):
                if board[j][i] == 'ðŸŒˆ':
                    board[j][i] = 'â¬›'
        print('orig board2')
        for row in original_board:
            print(' '.join(row))'''



def przesun_czarne_do_gory(tablica):
        wysokosc = len(tablica)
        szerokosc = len(tablica[0])

        # Iterujemy po kolumnach tablicy
        for kolumna in range(szerokosc):
            # Tworzymy listÄ™ zawierajÄ…cÄ… kolumnÄ™
            kolumna_tablicy = [tablica[wiersz][kolumna] for wiersz in range(wysokosc)]
            # Usuwamy wszystkie czarne bloki z kolumny
            kolumna_bez_czarnych = [blok for blok in kolumna_tablicy if blok != "â¬›"]
            # WypeÅ‚niamy poczÄ…tkowÄ… czÄ™Å›Ä‡ kolumny czarnymi blokami
            kolumna_tablicy = ["â¬›"] * (wysokosc - len(kolumna_bez_czarnych)) + kolumna_bez_czarnych
            # Aktualizujemy kolumnÄ™ tablicy wejÅ›ciowej
            for wiersz in range(wysokosc):
                tablica[wiersz][kolumna] = kolumna_tablicy[wiersz]

        return tablica


def group_positions(positions):
    # Initialize an empty list to store groups
    groups = []

    # Iterate through each position
    for pos in positions:
        # Check if the position can be added to an existing group
        added_to_group = False
        for group in groups:
            for group_pos in group:
                # Check if the position is adjacent to any position in the group
                if abs(pos[0] - group_pos[0]) <= 1 and abs(pos[1] - group_pos[1]) <= 1:
                    group.append(pos)
                    added_to_group = True
                    # print(f'{groups}')
                    break
            if added_to_group:
                # print(f'{groups}')
                break

        # If not added to any existing group, create a new group
        if not added_to_group:
            groups.append([pos])
    print(f' groups: {groups}')
    return groups


def explode_gem(board,y,x,strin,board_to_overwrite):
    print(f'board state:')
    score= 0
    gem_exploded = 0
    for row in board:
        print(' '.join(row))
    if board[y][x] == 'â¬›': return
    board2 = copy.deepcopy(board)
    print(f'{strin}, x:{x}, y:{y} ')
    print('board to voerwrite')
    for row in board_to_overwrite:
        print(' '.join(row))

    print('---------------------')
    pos_of_powered = []
    powered_gems_array = ['ðŸŸ£', 'âšª', 'ðŸŸ ', 'ðŸ”´', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ¡']

    for i in range(8):
        for j in range(8):
            if original_board[j][i] in powered_gems_array:
                pos = (i,j)
                pos_of_powered.append(pos)

    print(f'powered gem pos {pos_of_powered}')


    gem_groups =group_positions(pos_of_powered)
    gem = (x,y)
    group_of_gems = [] #chain
    #print(f'orig board 2{original_board}')
    for group in gem_groups:
        if gem in group:
            print(f'gem found in group {group}')
            group_of_gems = group
    print(f' remaining pos {pos}')
    for pos in group_of_gems:
        for i in range(pos[0] - 1, pos[0] + 2):
            for j in range(pos[1] - 1, pos[1] + 2):
                if i > -1 and i < 8 and j > -1 and j < 8:
                    board2[j][i] = 'â¬›'
        score+=300
        gem_exploded +=1

    print('test score')

    print('state of board after explode')
    for row in board2:
        print(' '.join(row))

    print('state of board after explode with other black places')

    for i in range(8):
        for j in range(8):
            if board2[j][i] == 'â¬›' or board2[j][i] == 'ðŸŒˆ':
                board_to_overwrite[j][i] = 'â¬›'
    for row in board_to_overwrite:
        print(' '.join(row))
    #explode_gem(board2, 4, 6, 'sdfg')
    board2 = original_board
    # WywoÅ‚anie funkcji i wydrukowanie wyniku
    print('------------------------')
    wynik = przesun_czarne_do_gory(board_to_overwrite)
    for wiersz in wynik:
        print(" ".join(wiersz))
    for i in range(8):
        for j in range(8):
            if board_to_overwrite[j][i] == 'â¬›':
                score += 100

    print(score - gem_exploded*100)







final_board =\
[['ðŸŸ§', 'ðŸŸ¨', 'ðŸŸ¦', 'ðŸŸ§', 'ðŸŸ¨', 'â¬œ', 'ðŸŸ¦', 'ðŸŸª'],
['ðŸŸ©', 'â¬œ', 'â¬œ', 'ðŸŸª', 'ðŸŸ©', 'ðŸŸ¨', 'â¬œ', 'ðŸŸ©'],
['ðŸŸ¨', 'ðŸŸ§', 'ðŸŸ¥', 'ðŸŸ¦', 'â¬œ', 'ðŸŸ©', 'â¬œ', 'â¬œ'],
['ðŸŸ¦', 'ðŸŸ¥', 'ðŸŸª', 'ðŸŸª', 'â¬œ', 'ðŸŸª', 'ðŸŸ§', 'ðŸŸ¥'],
['ðŸŸ§', 'ðŸŒˆ', 'â¬œ', 'âšª', 'ðŸŸ¦', 'ðŸŸ§', 'ðŸ”µ', 'ðŸŸ¦'],
['ðŸŸ¥', 'ðŸŸª', 'â¬œ', 'ðŸŸ ', 'ðŸŸª', 'ðŸŸ¥', 'ðŸŸ§', 'ðŸŸ¥'],
['ðŸŸ¥', 'ðŸŸ¥', 'ðŸŸ¨', 'ðŸ”µ', 'ðŸŸ¨', 'ðŸŸ¥', 'ðŸŸª', 'ðŸŸª'],
['ðŸŸ§', 'ðŸŸ¨', 'ðŸŸª', 'ðŸŸ¥', 'â¬œ', 'ðŸŸ©', 'ðŸŸ¦', 'ðŸŸª']]
#check_for_moves(final_board)
test()
#explode_gem(final_board, 6, 3, 'sdfg')


#cProfile.run('test()')




'''def explode_gem_test(board,y,x,strin):
    pos_of_powered = []
    powered_gems_array = ['ðŸŸ£', 'âšª', 'ðŸŸ ', 'ðŸ”´', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ¡']
    for i in range(8):
        for j in range(8):
            if board[j][i] in powered_gems_array:
                pos = (i,j)
                pos_of_powered.append(pos)
    print(f'powered gem pos {pos_of_powered}')

    def group_positions(positions):
        # Initialize an empty list to store groups
        groups = []

        # Iterate through each position
        for pos in positions:
            # Check if the position can be added to an existing group
            added_to_group = False
            for group in groups:
                for group_pos in group:
                    # Check if the position is adjacent to any position in the group
                    if abs(pos[0] - group_pos[0]) <= 1 and abs(pos[1] - group_pos[1]) <= 1:
                        group.append(pos)
                        added_to_group = True
                        #print(f'{groups}')
                        break
                if added_to_group:
                    #print(f'{groups}')
                    break

            # If not added to any existing group, create a new group
            if not added_to_group:
                groups.append([pos])
        print(f'{groups}')
        return groups

    gem_groups =group_positions(pos_of_powered)
    gem = (x,y)
    group_of_gems = [] #chain

    for group in gem_groups:
        if gem in group:
            print(f'gem found in group {group}')
            group_of_gems = group

    for pos in group_of_gems:

        for i in range(pos[0]-1, pos[0]+2):
            for j in range(pos[1]-1, pos[1]+2):
                if i > -1 and i < 8 and j > -1 and j < 8:
                    board[j][i] = 'â¬›'
    
    gem_to_explode = []
    board = copy.deepcopy(original_board)
    powered_gems_array = ['ðŸŸ£', 'âšª', 'ðŸŸ ', 'ðŸ”´', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ¡']
    print(f'pos of gem exploding gem {y} {x}')
    for row in board:
        print(' '.join(row))
    print(f'gem to explode {gem_to_explode}')
    #print('exploding ')
    for gems in gem_to_explode:
        for i in range(gems[0]-1,gems[0]+2):
            for j in range(gems[1]-1,gems[1]+2):

                board[j][i] = 'â¬›'
                
    print('state of board after explode')
    for row in board:
        print(' '.join(row))'''

#explode_gem_test(final_board, 0, 0, 's')
