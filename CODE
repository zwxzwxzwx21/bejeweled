import pyautogui
import time
import numpy as np
import matplotlib.pyplot as plt
from PIL import ImageGrab, Image, ImageEnhance
import cv2
from matplotlib import pyplot as plt
import subprocess
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
start_time =time.time()
#opening the game
subprocess.Popen(["D:\\Bejeweled 2 Deluxe\\Bejeweled2.exe"])

#windows title moving to the corner
win = pyautogui.getWindowsWithTitle('Bejeweled 2 Deluxe 1.0')[0]

win.activate()
win.moveTo(0, 0)



#(82, 76, 24),
wylosowane_kolory = [(199, 22, 199), (200, 200, 100), (230, 220, 220), (255,165,0), (49, 171, 253), (19, 202, 19),
                     (255, 99, 99),(0,0,0),(82, 76, 24),(255,255,255)]  # in order: pink, yellow,white, orange, blue, green,red
kolory = ['pink','yellow','white','orange','blue','green','red','black','brown','rainbow']


timer = 0
#coordinated for drawing dots on image
kordy = []
a = ''
import cProfile
def test():

    x, y = pyautogui.position()
    width, height = 85 * 8, 84 * 8

    screenshot = ImageGrab.grab(bbox=(305, 62, 305 + width, 62 + height))


    plt.imshow(screenshot)
    plt.axis('on')  # WyÅ‚Ä…cz osie
    plt.show()




    array_color = []
    for i in range(3):

        x, y = 305, 62
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

        #print(aktualny_kolor)
        #print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):
            for i in range(8):
                new_x = x + 85 * i + 41
                new_y = y + 84 * j + 42

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                #print(aktualny_kolor)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))

                #print(najblizszy_kolor)
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        #print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›',
            'brown': '?',
            'rainbow': 'R'
        }
        color = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color[i][j] = color_mapping[colors[index]]
        #for row in color:
            #print(' '.join(row))
        #print(color)
    #print(array_color)
    for i in range(3):

        x, y = 305, 62
        aktualny_kolor = pyautogui.pixel(x, y)
        najblizszy_kolor = min(wylosowane_kolory,
                               key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
        #variable to make dots even or something
        t,t2 = 0 , -1
        #print(aktualny_kolor)
        #print(najblizszy_kolor)
        colors =[]
        #print(colors)
        for j in range(8):

            for i in range(8):
                t+=1
                if t == 2:
                    t2+=1
                new_x = x + 85 * i + 6 - i + t2 + 2
                new_y = y + 84 * j + 42
                kordy.append((new_x-305,new_y-62))

                aktualny_kolor = pyautogui.pixel(new_x, new_y)
                #print(aktualny_kolor)
                najblizszy_kolor = min(wylosowane_kolory,
                                       key=lambda k: sum(abs(k[i] - aktualny_kolor[i]) for i in range(3)))
                #print(najblizszy_kolor)
                for k, kolor in enumerate(wylosowane_kolory):
                    if najblizszy_kolor == kolor:
                        colors.append(kolory[k])
                        break
        #print(colors)
        array_color.append(colors)
        color_mapping = {
            'pink': 'ðŸŸª',
            'yellow': 'ðŸŸ¨',
            'white': 'â¬œ',
            'orange': 'ðŸŸ§',
            'blue': 'ðŸŸ¦',
            'green': 'ðŸŸ©',
            'red': 'ðŸŸ¥',
            'black': 'â¬›',
            'brown': 'P',
            'rainbow': 'R'
        }
        color_power = [['' for _ in range(8)] for _ in range(8)]
        for i in range(8):
            for j in range(8):
                index = (i * 8 + j) % len(colors)
                color_power[i][j] = color_mapping[colors[index]]
        #for row in color_power:
            #print(' '.join(row))
        #print(f' [color_power]= {color_power}')
    #print(array_color)
    #print(len(kordy))
    #print(kordy)
    # Wykonaj zrzut ekranu
    '''width, height = 85 * 8, 84 * 8
    xx, yy = 305,62
    # Wykonaj zrzut ekranu w okreÅ›lonym obszarze
    screenshot = pyautogui.screenshot(region=(xx, yy, width, height))
    screenshot.save("screenshot.png")

    # ZaÅ‚aduj zrzut ekranu
    edited_screenshot = Image.open("screenshot.png")


    # Zapisz zedytowany zrzut ekranu
    edited_screenshot.save("edited_screenshot.png")

    image = cv2.imread('screenshot.png')
    for x, y in kordy:
        image = cv2.circle(image, (x, y), radius=0, color=(255, 255, 255), thickness=-3)

    # WyÅ›wietl obraz
    cv2.imshow('Modified Image', image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()'''
    # compare arrays to determine what is what
    first_color_array = []
    second_color_array = []
    for gem in color:
        first_color_array+=gem
    #print(first_color_array)
    for gem in color_power:
        second_color_array+=gem


    #comparing
    #new array to have new board state
    pre_final_board = []
    for i in range(64):
        if second_color_array[i] == 'P' and first_color_array[i] == 'R':
            pre_final_board.append('âšª')
        elif second_color_array[i] == 'â¬›' and first_color_array[i] == 'R':
            pre_final_board.append('ðŸŒˆ')
        elif first_color_array[i] == 'ðŸŸ¨' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¨')
        elif first_color_array[i] == 'ðŸŸ¥' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¥')
        elif first_color_array[i] == 'ðŸŸ§' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ§')
        elif first_color_array[i] == 'ðŸŸ¦' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ¦')
        elif first_color_array[i] == 'ðŸŸ©' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸ©')
        elif first_color_array[i] == 'ðŸŸª' and second_color_array[i] != 'P':
            pre_final_board.append('ðŸŸª')
        elif first_color_array[i] == 'â¬œ' and second_color_array[i] != 'P':
            pre_final_board.append('â¬œ')
        elif first_color_array[i] == 'ðŸŸ¨' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ¡')
        elif first_color_array[i] == 'ðŸŸ¥' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸ”´')
        elif first_color_array[i] == 'ðŸŸ§' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ ')
        elif first_color_array[i] == 'ðŸŸ¦' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸ”µ')
        elif first_color_array[i] == 'ðŸŸ©' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ¢')
        elif first_color_array[i] == 'ðŸŸª' and second_color_array[i] == 'P':
            pre_final_board.append('ðŸŸ£')
    # ðŸ”´ðŸŸ ðŸŸ¡ðŸŸ¢ðŸ”µðŸŸ£
    print(f'pre array{pre_final_board}')
    final_board = [['' for _ in range(8)] for _ in range(8)]
    color_mapping = {
        'ðŸŸ¨': 'ðŸŸ¨',
        'ðŸŸ¦': 'ðŸŸ¦',
        'ðŸŸª': 'ðŸŸª',
        'â¬œ': 'â¬œ',
        'ðŸŸ©': 'ðŸŸ©',
        'ðŸŸ§': 'ðŸŸ§',
        'ðŸŸ¥': 'ðŸŸ¥',
        'ðŸ”µ': 'ðŸ”µ',
        'âšª': 'âšª',
        'ðŸŒˆ': 'ðŸŒˆ',
        'ðŸ”´': 'ðŸ”´',
        'ðŸŸ£': 'ðŸŸ£',
        'ðŸŸ¢': 'ðŸŸ¢',
        'ðŸŸ ': 'ðŸŸ ',
        'ðŸŸ¡': 'ðŸŸ¡',
    }

    for i, emoji in enumerate(pre_final_board):
        row = i // 8
        col = i % 8
        final_board[row][col] = color_mapping.get(emoji, 'unknown')

    # WyÅ›wietlenie ramki final_board
    for row in final_board:
        print(row)
    end_time = time.time()
    print(f' elapsed in seconds:{end_time - start_time}')

    check_for_moves(final_board)

def check_for_moves(final_board):
    horizontal_pair_of_gems = []
    vertical_pair_of_gems = []
    available_vertical_moves = 0
    for i in range(8):
        for j in range(7):
            if final_board[i][j] == final_board[i][j + 1]:
                horizontal_pair_of_gems.append(((j,i),(j+1,i)))
    for j in range(8):
        for i in range(7):
            if final_board[i][j] == final_board[i+1][j]:
                vertical_pair_of_gems.append(((j,i),(j,i+1)))
    print('vertical pairs:')
    print(vertical_pair_of_gems)
    print('horizontal pairs:')
    print(horizontal_pair_of_gems)
    #print(horizontal_pair_of_gems[0][0])
    #print(len(horizontal_pair_of_gems))
    #for i in range(len(horizontal_pair_of_gems)):
    #if final_board[horizontal_pair_of_gems[i][0][0]][horizontal_pair_of_gems[i][0][1]] == final_board[horizontal_pair_of_gems[i][0][0]][horizontal_pair_of_gems[i][0][1]]
    #print(final_board[vertical_pair_of_gems[2][0][0]][vertical_pair_of_gems[2][0][1]])

    for i in range(len(vertical_pair_of_gems)):
        try:
            print(vertical_pair_of_gems[i])
            print(final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])])

            if (vertical_pair_of_gems[i][0][0])-1 < 0 or (vertical_pair_of_gems[i][0][1])-1  < 0:

                print('incorrect position for gem 1 higher and 1 to the left')



            else:

                print(f'gem higher 1 and left:{final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')

                    available_vertical_moves += 1




            print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][0][0])-1} {(vertical_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][0][0]) + 1 >8 or (vertical_pair_of_gems[i][0][1])-1  < 0 or (vertical_pair_of_gems[i][0][1]) > 8: # might have errors

                print('incorrect position for gem 1 higher and 1 to the right')
                print((vertical_pair_of_gems[i][0][0]) + 1,(vertical_pair_of_gems[i][0][1])-1)




            else:

                print(f' gem higher 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-1][(vertical_pair_of_gems[i][0][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')

                    available_vertical_moves += 1



            print(f'{bcolors.WARNING} position of gem in the right{(vertical_pair_of_gems[i][0][0]) + 1} {(vertical_pair_of_gems[i][0][1]-1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1])-2 < 0:

                print('incorrect position for gem 2 higher')




            else:

                print(f' gem higher by 2:{final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]}') # nad parÄ…



                if final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])] == final_board[(vertical_pair_of_gems[i][0][1])-2][(vertical_pair_of_gems[i][0][0])]:

                    available_vertical_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 HIGHER{bcolors.ENDC}')




            print(f'{bcolors.WARNING}position of game 2 higher {(vertical_pair_of_gems[i][0][0])} {(vertical_pair_of_gems[i][0][1]) - 2}{bcolors.ENDC}')

            print('------------')

        except:pass
    print(f'=================================================')
    for i in range(len(vertical_pair_of_gems)):
        try:
            print(vertical_pair_of_gems[i])
            print(final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])])

            if (vertical_pair_of_gems[i][1][0])-1 < 0 or (vertical_pair_of_gems[i][1][1])+1 > 8:

                print('incorrect position for gem 1 lower and 1 to the left')



            else:

                print(f'gem lower 1 and left:{final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]}') # lewy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 LEFT{bcolors.ENDC}')

                    available_vertical_moves += 1




            print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][1][0])-1} {(vertical_pair_of_gems[i][1][1])+1}{bcolors.ENDC}')




            if (vertical_pair_of_gems[i][1][0]) + 1 >8 or (vertical_pair_of_gems[i][1][1])+1  > 8 or (vertical_pair_of_gems[i][1][1]) > 8: # might have errors

                print('incorrect position for gem 1 lower and 1 to the right')
                print((vertical_pair_of_gems[i][1][0]) + 1,(vertical_pair_of_gems[i][1][1])+1)




            else:

                print(f' gem lower 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+1][(vertical_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 lower 1 RIGHT{bcolors.ENDC}')

                    available_vertical_moves += 1



            print(f'{bcolors.WARNING} position of gem in the right{(vertical_pair_of_gems[i][1][0]) + 1} {(vertical_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (vertical_pair_of_gems[i][1][0]) < 0 or (vertical_pair_of_gems[i][1][1])+2 > 8:

                print('incorrect position for gem 2 lower')




            else:

                print(f' gem lower by 2:{final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][1][0])]}') # pod parÄ…



                if final_board[(vertical_pair_of_gems[i][1][1])][(vertical_pair_of_gems[i][1][0])] == final_board[(vertical_pair_of_gems[i][1][1])+2][(vertical_pair_of_gems[i][0][0])]:

                    available_vertical_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 lower{bcolors.ENDC}')




            print(f'{bcolors.WARNING}position of game 2 lower {(vertical_pair_of_gems[i][1][0])} {(vertical_pair_of_gems[i][1][1]) - 2}{bcolors.ENDC}')

            print('------------')

        except:pass
    #print(f'{bcolors.FAIL} VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')
    print(f'{bcolors.OKBLUE}VERTICAL MOVES: {available_vertical_moves}{bcolors.ENDC}')

    #HORIZONTAL EASY MOVES
    available_horizontal_moves = 0
    print(f'################ HORIZONTAL MOVES #####################')
    for i in range(len(horizontal_pair_of_gems)):
        try:
            print(horizontal_pair_of_gems[i])
            print(final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])])

            if (horizontal_pair_of_gems[i][0][0])-1 < 0 or (horizontal_pair_of_gems[i][0][1])-1  < 0:

                print('incorrect position for gem 1 higher and 1 to the left')



            else:

                print(f'gem higher 1 and left:{final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 LEFT{bcolors.ENDC}')

                    available_horizontal_moves += 1




            print(f'{bcolors.WARNING}position of gen 1 higher on the left {(horizontal_pair_of_gems[i][0][0])-1} {(horizontal_pair_of_gems[i][0][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][0][0]) - 1 <0 or (horizontal_pair_of_gems[i][0][1])+1  > 8 or (horizontal_pair_of_gems[i][0][1]) > 8: # might have errors

                print('incorrect position for gem 1 lower and 1 to the left')
                print((horizontal_pair_of_gems[i][0][0]) - 1,(horizontal_pair_of_gems[i][0][1])+1)




            else:

                print(f' gem lower 1 and 1 to the left: {final_board[(horizontal_pair_of_gems[i][0][1])+1][(horizontal_pair_of_gems[i][0][0])-1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])] == final_board[(horizontal_pair_of_gems[i][0][1])-1][(horizontal_pair_of_gems[i][0][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 LEFT{bcolors.ENDC}')

                    available_horizontal_moves += 1



            print(f'{bcolors.WARNING} position of gem in the left{(horizontal_pair_of_gems[i][0][0]) - 1} {(horizontal_pair_of_gems[i][0][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (horizontal_pair_of_gems[i][0][0])-2 < 0 or (horizontal_pair_of_gems[i][0][1]) < 0:

                print('incorrect position for gem 2 to left')




            else:

                print(f' gem left  by 2:{final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])-2] == final_board[(horizontal_pair_of_gems[i][0][1])][(horizontal_pair_of_gems[i][0][0])]:

                    available_horizontal_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO LEFT{bcolors.ENDC}')




            print(f'{bcolors.WARNING}position of game 2 to left {(horizontal_pair_of_gems[i][0][0])-2} {(horizontal_pair_of_gems[i][0][1])}{bcolors.ENDC}')

            print('------------')

        except:pass
    print('##################################')
    for i in range(len(horizontal_pair_of_gems)):
        try:
            print(horizontal_pair_of_gems[i])
            print(final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])])

            if (horizontal_pair_of_gems[i][1][0])+1 > 8 or (horizontal_pair_of_gems[i][1][1])-1  < 0:

                print('incorrect position for gem 1 higher and 1 to the right')



            else:

                print(f'gem higher 1 and right:{final_board[(horizontal_pair_of_gems[i][1][1])-1][(horizontal_pair_of_gems[i][1][0])+1]}') # lewy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])-1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 HIGHER 1 RIGHT{bcolors.ENDC}')

                    available_horizontal_moves += 1




            print(f'{bcolors.WARNING}position of gen 1 higher on the right {(horizontal_pair_of_gems[i][1][0])+1} {(horizontal_pair_of_gems[i][1][1])-1}{bcolors.ENDC}')




            if (horizontal_pair_of_gems[i][1][0]) + 1 <0 or (horizontal_pair_of_gems[i][1][1])+1  > 8 or (horizontal_pair_of_gems[i][1][1]) > 8: # might have errors

                print('incorrect position for gem 1 lower and 1 to the right')
                print((horizontal_pair_of_gems[i][1][0]) + 1,(horizontal_pair_of_gems[i][1][1])+1)




            else:

                print(f' gem lower 1 and 1 to the right: {final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]}') # prawy



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])] == final_board[(horizontal_pair_of_gems[i][1][1])+1][(horizontal_pair_of_gems[i][1][0])+1]:

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 1 LOWER 1 RIGHT{bcolors.ENDC}')

                    available_horizontal_moves += 1



            print(f'{bcolors.WARNING} position of gem in the right{(horizontal_pair_of_gems[i][1][0]) + 1} {(horizontal_pair_of_gems[i][1][1]+1)}{bcolors.ENDC}')

            #print(f' MOVES: {available_vertical_moves}')

            if (horizontal_pair_of_gems[i][1][0])+2 > 8 or (horizontal_pair_of_gems[i][1][1]) < 0:

                print('incorrect position for gem 2 to right')




            else:

                print(f' gem right  by 2:{final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2]}') # nad parÄ…



                if final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])+2] == final_board[(horizontal_pair_of_gems[i][1][1])][(horizontal_pair_of_gems[i][1][0])]:

                    available_horizontal_moves += 1

                    print(f'{bcolors.OKBLUE}MOVE FOUND FOR GEM 2 TO RIGHT{bcolors.ENDC}')




            print(f'{bcolors.WARNING}position of game 2 to right {(horizontal_pair_of_gems[i][1][0])+2} {(horizontal_pair_of_gems[i][1][1])}{bcolors.ENDC}')

            print('------------')

        except:pass
    print(f'{bcolors.OKBLUE}HORIZONTAL MOVES: {available_horizontal_moves}{bcolors.ENDC}')
    ''' for i in range(len(vertical_pair_of_gems)):
        try:
            print(vertical_pair_of_gems[i])
            print(final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])])

            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1])  < 0:
                print('incorrect position for gem 1 higher and 1 to the left')
            else:
                print(f'gem higher 1 and left:{final_board[(vertical_pair_of_gems[i][0][1])+1][(vertical_pair_of_gems[i][0][0])+1]}') # lewy
            print(f'{bcolors.WARNING}position of gen on the left {(vertical_pair_of_gems[i][0][0])+1} {(vertical_pair_of_gems[i][0][1]+1)}{bcolors.ENDC}')

            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1])  > 8: # might have errors
                print('incorrect position for gem 1 higher and 1 to the right')
            else:
                print(f' gem higher 1 and 1 to the right: {final_board[(vertical_pair_of_gems[i][0][1])][(vertical_pair_of_gems[i][0][0])]}') # prawy
            print(f'{bcolors.WARNING} position of gem in the right{(vertical_pair_of_gems[i][0][0])} {(vertical_pair_of_gems[i][0][1])}{bcolors.ENDC}')

            if (vertical_pair_of_gems[i][0][0]) < 0 or (vertical_pair_of_gems[i][0][1]) < 0:
                print('incorrect position for gem 2 higher')
            else:
                print(f' gem higher by 2:{final_board[(vertical_pair_of_gems[i][0][0])][(vertical_pair_of_gems[i][0][1])]}') # nad parÄ…
            print(f'{bcolors.WARNING}position of game 2 higher {(vertical_pair_of_gems[i][0][0])} {(vertical_pair_of_gems[i][0][1])}{bcolors.ENDC}')

            print('------------')
        except:pass'''
    '''for i in range(len(horizontal_pair_of_gems)):
        print(horizontal_pair_of_gems[i][0])
        print(horizontal_pair_of_gems[i][0][0])
    for i in range(len(horizontal_pair_of_gems)):
        print(horizontal_pair_of_gems[i][0][1])'''
test()

#cProfile.run('test()')
